// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace h264bsd
{
    public enum H264BSD
    {
        H264BSD_RDY = 0,
        H264BSD_PIC_RDY = 1,
        H264BSD_HDRS_RDY = 2,
        H264BSD_ERROR = 3,
        H264BSD_PARAM_SET_ERROR = 4,
        H264BSD_MEMALLOC_ERROR = 5
    }

    public unsafe partial class h264bsd_decoder
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdInit@@YAIPEAUstorage@@I@Z")]
            internal static extern uint H264bsdInit(global::System.IntPtr pStorage, uint noOutputReordering);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdDecode@@YAIPEAUstorage@@PEAEIIPEAI@Z")]
            internal static extern uint H264bsdDecode(global::System.IntPtr pStorage, byte* byteStrm, uint len, uint picId, uint* readBytes);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdShutdown@@YAXPEAUstorage@@@Z")]
            internal static extern void H264bsdShutdown(global::System.IntPtr pStorage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdNextOutputPicture@@YAPEAEPEAUstorage@@PEAI11@Z")]
            internal static extern byte* H264bsdNextOutputPicture(global::System.IntPtr pStorage, uint* picId, uint* isIdrPic, uint* numErrMbs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdNextOutputPictureRGBA@@YAPEAIPEAUstorage@@PEAI11@Z")]
            internal static extern uint* H264bsdNextOutputPictureRGBA(global::System.IntPtr pStorage, uint* picId, uint* isIdrPic, uint* numErrMbs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdNextOutputPictureBGRA@@YAPEAIPEAUstorage@@PEAI11@Z")]
            internal static extern uint* H264bsdNextOutputPictureBGRA(global::System.IntPtr pStorage, uint* picId, uint* isIdrPic, uint* numErrMbs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdNextOutputPictureYCbCrA@@YAPEAIPEAUstorage@@PEAI11@Z")]
            internal static extern uint* H264bsdNextOutputPictureYCbCrA(global::System.IntPtr pStorage, uint* picId, uint* isIdrPic, uint* numErrMbs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdPicWidth@@YAIPEAUstorage@@@Z")]
            internal static extern uint H264bsdPicWidth(global::System.IntPtr pStorage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdPicHeight@@YAIPEAUstorage@@@Z")]
            internal static extern uint H264bsdPicHeight(global::System.IntPtr pStorage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdVideoRange@@YAIPEAUstorage@@@Z")]
            internal static extern uint H264bsdVideoRange(global::System.IntPtr pStorage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdMatrixCoefficients@@YAIPEAUstorage@@@Z")]
            internal static extern uint H264bsdMatrixCoefficients(global::System.IntPtr pStorage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdCroppingParams@@YAXPEAUstorage@@PEAI1111@Z")]
            internal static extern void H264bsdCroppingParams(global::System.IntPtr pStorage, uint* croppingFlag, uint* left, uint* width, uint* top, uint* height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdSampleAspectRatio@@YAXPEAUstorage@@PEAI1@Z")]
            internal static extern void H264bsdSampleAspectRatio(global::System.IntPtr pStorage, uint* sarWidth, uint* sarHeight);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdCheckValidParamSets@@YAIPEAUstorage@@@Z")]
            internal static extern uint H264bsdCheckValidParamSets(global::System.IntPtr pStorage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdFlushBuffer@@YAXPEAUstorage@@@Z")]
            internal static extern void H264bsdFlushBuffer(global::System.IntPtr pStorage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdProfile@@YAIPEAUstorage@@@Z")]
            internal static extern uint H264bsdProfile(global::System.IntPtr pStorage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdAlloc@@YAPEAUstorage@@XZ")]
            internal static extern global::System.IntPtr H264bsdAlloc();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdFree@@YAXPEAUstorage@@@Z")]
            internal static extern void H264bsdFree(global::System.IntPtr pStorage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdConvertToRGBA@@YAXIIPEAEPEAI@Z")]
            internal static extern void H264bsdConvertToRGBA(uint width, uint height, byte* data, uint* pOutput);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdConvertToBGRA@@YAXIIPEAEPEAI@Z")]
            internal static extern void H264bsdConvertToBGRA(uint width, uint height, byte* data, uint* pOutput);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdConvertToYCbCrA@@YAXIIPEAEPEAI@Z")]
            internal static extern void H264bsdConvertToYCbCrA(uint width, uint height, byte* data, uint* pOutput);
        }

        public static uint H264bsdInit(global::h264bsd.Storage pStorage, uint noOutputReordering)
        {
            var __arg0 = ReferenceEquals(pStorage, null) ? global::System.IntPtr.Zero : pStorage.__Instance;
            var __ret = __Internal.H264bsdInit(__arg0, noOutputReordering);
            return __ret;
        }

        public static uint H264bsdDecode(global::h264bsd.Storage pStorage, byte* byteStrm, uint len, uint picId, ref uint readBytes)
        {
            var __arg0 = ReferenceEquals(pStorage, null) ? global::System.IntPtr.Zero : pStorage.__Instance;
            fixed (uint* __readBytes4 = &readBytes)
            {
                var __arg4 = __readBytes4;
                var __ret = __Internal.H264bsdDecode(__arg0, byteStrm, len, picId, __arg4);
                return __ret;
            }
        }

        public static void H264bsdShutdown(global::h264bsd.Storage pStorage)
        {
            var __arg0 = ReferenceEquals(pStorage, null) ? global::System.IntPtr.Zero : pStorage.__Instance;
            __Internal.H264bsdShutdown(__arg0);
        }

        public static byte* H264bsdNextOutputPicture(global::h264bsd.Storage pStorage, ref uint picId, ref uint isIdrPic, ref uint numErrMbs)
        {
            var __arg0 = ReferenceEquals(pStorage, null) ? global::System.IntPtr.Zero : pStorage.__Instance;
            fixed (uint* __picId1 = &picId)
            {
                var __arg1 = __picId1;
                fixed (uint* __isIdrPic2 = &isIdrPic)
                {
                    var __arg2 = __isIdrPic2;
                    fixed (uint* __numErrMbs3 = &numErrMbs)
                    {
                        var __arg3 = __numErrMbs3;
                        var __ret = __Internal.H264bsdNextOutputPicture(__arg0, __arg1, __arg2, __arg3);
                        return __ret;
                    }
                }
            }
        }

        public static uint* H264bsdNextOutputPictureRGBA(global::h264bsd.Storage pStorage, ref uint picId, ref uint isIdrPic, ref uint numErrMbs)
        {
            var __arg0 = ReferenceEquals(pStorage, null) ? global::System.IntPtr.Zero : pStorage.__Instance;
            fixed (uint* __picId1 = &picId)
            {
                var __arg1 = __picId1;
                fixed (uint* __isIdrPic2 = &isIdrPic)
                {
                    var __arg2 = __isIdrPic2;
                    fixed (uint* __numErrMbs3 = &numErrMbs)
                    {
                        var __arg3 = __numErrMbs3;
                        var __ret = __Internal.H264bsdNextOutputPictureRGBA(__arg0, __arg1, __arg2, __arg3);
                        return __ret;
                    }
                }
            }
        }

        public static uint* H264bsdNextOutputPictureBGRA(global::h264bsd.Storage pStorage, ref uint picId, ref uint isIdrPic, ref uint numErrMbs)
        {
            var __arg0 = ReferenceEquals(pStorage, null) ? global::System.IntPtr.Zero : pStorage.__Instance;
            fixed (uint* __picId1 = &picId)
            {
                var __arg1 = __picId1;
                fixed (uint* __isIdrPic2 = &isIdrPic)
                {
                    var __arg2 = __isIdrPic2;
                    fixed (uint* __numErrMbs3 = &numErrMbs)
                    {
                        var __arg3 = __numErrMbs3;
                        var __ret = __Internal.H264bsdNextOutputPictureBGRA(__arg0, __arg1, __arg2, __arg3);
                        return __ret;
                    }
                }
            }
        }

        public static uint* H264bsdNextOutputPictureYCbCrA(global::h264bsd.Storage pStorage, ref uint picId, ref uint isIdrPic, ref uint numErrMbs)
        {
            var __arg0 = ReferenceEquals(pStorage, null) ? global::System.IntPtr.Zero : pStorage.__Instance;
            fixed (uint* __picId1 = &picId)
            {
                var __arg1 = __picId1;
                fixed (uint* __isIdrPic2 = &isIdrPic)
                {
                    var __arg2 = __isIdrPic2;
                    fixed (uint* __numErrMbs3 = &numErrMbs)
                    {
                        var __arg3 = __numErrMbs3;
                        var __ret = __Internal.H264bsdNextOutputPictureYCbCrA(__arg0, __arg1, __arg2, __arg3);
                        return __ret;
                    }
                }
            }
        }

        public static uint H264bsdPicWidth(global::h264bsd.Storage pStorage)
        {
            var __arg0 = ReferenceEquals(pStorage, null) ? global::System.IntPtr.Zero : pStorage.__Instance;
            var __ret = __Internal.H264bsdPicWidth(__arg0);
            return __ret;
        }

        public static uint H264bsdPicHeight(global::h264bsd.Storage pStorage)
        {
            var __arg0 = ReferenceEquals(pStorage, null) ? global::System.IntPtr.Zero : pStorage.__Instance;
            var __ret = __Internal.H264bsdPicHeight(__arg0);
            return __ret;
        }

        public static uint H264bsdVideoRange(global::h264bsd.Storage pStorage)
        {
            var __arg0 = ReferenceEquals(pStorage, null) ? global::System.IntPtr.Zero : pStorage.__Instance;
            var __ret = __Internal.H264bsdVideoRange(__arg0);
            return __ret;
        }

        public static uint H264bsdMatrixCoefficients(global::h264bsd.Storage pStorage)
        {
            var __arg0 = ReferenceEquals(pStorage, null) ? global::System.IntPtr.Zero : pStorage.__Instance;
            var __ret = __Internal.H264bsdMatrixCoefficients(__arg0);
            return __ret;
        }

        public static void H264bsdCroppingParams(global::h264bsd.Storage pStorage, ref uint croppingFlag, ref uint left, ref uint width, ref uint top, ref uint height)
        {
            var __arg0 = ReferenceEquals(pStorage, null) ? global::System.IntPtr.Zero : pStorage.__Instance;
            fixed (uint* __croppingFlag1 = &croppingFlag)
            {
                var __arg1 = __croppingFlag1;
                fixed (uint* __left2 = &left)
                {
                    var __arg2 = __left2;
                    fixed (uint* __width3 = &width)
                    {
                        var __arg3 = __width3;
                        fixed (uint* __top4 = &top)
                        {
                            var __arg4 = __top4;
                            fixed (uint* __height5 = &height)
                            {
                                var __arg5 = __height5;
                                __Internal.H264bsdCroppingParams(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5);
                            }
                        }
                    }
                }
            }
        }

        public static void H264bsdSampleAspectRatio(global::h264bsd.Storage pStorage, ref uint sarWidth, ref uint sarHeight)
        {
            var __arg0 = ReferenceEquals(pStorage, null) ? global::System.IntPtr.Zero : pStorage.__Instance;
            fixed (uint* __sarWidth1 = &sarWidth)
            {
                var __arg1 = __sarWidth1;
                fixed (uint* __sarHeight2 = &sarHeight)
                {
                    var __arg2 = __sarHeight2;
                    __Internal.H264bsdSampleAspectRatio(__arg0, __arg1, __arg2);
                }
            }
        }

        public static uint H264bsdCheckValidParamSets(global::h264bsd.Storage pStorage)
        {
            var __arg0 = ReferenceEquals(pStorage, null) ? global::System.IntPtr.Zero : pStorage.__Instance;
            var __ret = __Internal.H264bsdCheckValidParamSets(__arg0);
            return __ret;
        }

        public static void H264bsdFlushBuffer(global::h264bsd.Storage pStorage)
        {
            var __arg0 = ReferenceEquals(pStorage, null) ? global::System.IntPtr.Zero : pStorage.__Instance;
            __Internal.H264bsdFlushBuffer(__arg0);
        }

        public static uint H264bsdProfile(global::h264bsd.Storage pStorage)
        {
            var __arg0 = ReferenceEquals(pStorage, null) ? global::System.IntPtr.Zero : pStorage.__Instance;
            var __ret = __Internal.H264bsdProfile(__arg0);
            return __ret;
        }

        public static global::h264bsd.Storage H264bsdAlloc()
        {
            var __ret = __Internal.H264bsdAlloc();
            global::h264bsd.Storage __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::h264bsd.Storage.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::h264bsd.Storage) global::h264bsd.Storage.NativeToManagedMap[__ret];
            else __result0 = global::h264bsd.Storage.__CreateInstance(__ret);
            return __result0;
        }

        public static void H264bsdFree(global::h264bsd.Storage pStorage)
        {
            var __arg0 = ReferenceEquals(pStorage, null) ? global::System.IntPtr.Zero : pStorage.__Instance;
            __Internal.H264bsdFree(__arg0);
        }

        public static void H264bsdConvertToRGBA(uint width, uint height, byte* data, ref uint pOutput)
        {
            fixed (uint* __pOutput3 = &pOutput)
            {
                var __arg3 = __pOutput3;
                __Internal.H264bsdConvertToRGBA(width, height, data, __arg3);
            }
        }

        public static void H264bsdConvertToBGRA(uint width, uint height, byte* data, ref uint pOutput)
        {
            fixed (uint* __pOutput3 = &pOutput)
            {
                var __arg3 = __pOutput3;
                __Internal.H264bsdConvertToBGRA(width, height, data, __arg3);
            }
        }

        public static void H264bsdConvertToYCbCrA(uint width, uint height, byte* data, ref uint pOutput)
        {
            fixed (uint* __pOutput3 = &pOutput)
            {
                var __arg3 = __pOutput3;
                __Internal.H264bsdConvertToYCbCrA(width, height, data, __arg3);
            }
        }
    }

    public enum ASPECT_RATIO
    {
        ASPECT_RATIO_UNSPECIFIED = 0,
        ASPECT_RATIO_1_1 = 1,
        ASPECT_RATIO_12_11 = 2,
        ASPECT_RATIO_10_11 = 3,
        ASPECT_RATIO_16_11 = 4,
        ASPECT_RATIO_40_33 = 5,
        ASPECT_RATIO_24_11 = 6,
        ASPECT_RATIO_20_11 = 7,
        ASPECT_RATIO_32_11 = 8,
        ASPECT_RATIO_80_33 = 9,
        ASPECT_RATIO_18_11 = 10,
        ASPECT_RATIO_15_11 = 11,
        ASPECT_RATIO_64_33 = 12,
        ASPECT_RATIO_160_99 = 13,
        ASPECT_RATIO_EXTENDED_SAR = 255
    }

    public unsafe partial class HrdParametersT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 412)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint cpbCnt;

            [FieldOffset(4)]
            internal uint bitRateScale;

            [FieldOffset(8)]
            internal uint cpbSizeScale;

            [FieldOffset(12)]
            internal fixed uint bitRateValue[32];

            [FieldOffset(140)]
            internal fixed uint cpbSizeValue[32];

            [FieldOffset(268)]
            internal fixed uint cbrFlag[32];

            [FieldOffset(396)]
            internal uint initialCpbRemovalDelayLength;

            [FieldOffset(400)]
            internal uint cpbRemovalDelayLength;

            [FieldOffset(404)]
            internal uint dpbOutputDelayLength;

            [FieldOffset(408)]
            internal uint timeOffsetLength;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0hrdParameters_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.HrdParametersT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.HrdParametersT>();

        protected bool __ownsNativeInstance;

        internal static global::h264bsd.HrdParametersT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::h264bsd.HrdParametersT(native.ToPointer(), skipVTables);
        }

        internal static global::h264bsd.HrdParametersT __CreateInstance(global::h264bsd.HrdParametersT.__Internal native, bool skipVTables = false)
        {
            return new global::h264bsd.HrdParametersT(native, skipVTables);
        }

        private static void* __CopyValue(global::h264bsd.HrdParametersT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::h264bsd.HrdParametersT.__Internal));
            *(global::h264bsd.HrdParametersT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HrdParametersT(global::h264bsd.HrdParametersT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected HrdParametersT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public HrdParametersT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.HrdParametersT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public HrdParametersT(global::h264bsd.HrdParametersT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.HrdParametersT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::h264bsd.HrdParametersT.__Internal*) __Instance) = *((global::h264bsd.HrdParametersT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::h264bsd.HrdParametersT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint CpbCnt
        {
            get
            {
                return ((global::h264bsd.HrdParametersT.__Internal*) __Instance)->cpbCnt;
            }

            set
            {
                ((global::h264bsd.HrdParametersT.__Internal*)__Instance)->cpbCnt = value;
            }
        }

        public uint BitRateScale
        {
            get
            {
                return ((global::h264bsd.HrdParametersT.__Internal*) __Instance)->bitRateScale;
            }

            set
            {
                ((global::h264bsd.HrdParametersT.__Internal*)__Instance)->bitRateScale = value;
            }
        }

        public uint CpbSizeScale
        {
            get
            {
                return ((global::h264bsd.HrdParametersT.__Internal*) __Instance)->cpbSizeScale;
            }

            set
            {
                ((global::h264bsd.HrdParametersT.__Internal*)__Instance)->cpbSizeScale = value;
            }
        }

        public uint[] BitRateValue
        {
            get
            {
                uint[] __value = null;
                if (((global::h264bsd.HrdParametersT.__Internal*) __Instance)->bitRateValue != null)
                {
                    __value = new uint[32];
                    for (int i = 0; i < 32; i++)
                        __value[i] = ((global::h264bsd.HrdParametersT.__Internal*) __Instance)->bitRateValue[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((global::h264bsd.HrdParametersT.__Internal*)__Instance)->bitRateValue[i] = value[i];
                }
            }
        }

        public uint[] CpbSizeValue
        {
            get
            {
                uint[] __value = null;
                if (((global::h264bsd.HrdParametersT.__Internal*) __Instance)->cpbSizeValue != null)
                {
                    __value = new uint[32];
                    for (int i = 0; i < 32; i++)
                        __value[i] = ((global::h264bsd.HrdParametersT.__Internal*) __Instance)->cpbSizeValue[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((global::h264bsd.HrdParametersT.__Internal*)__Instance)->cpbSizeValue[i] = value[i];
                }
            }
        }

        public uint[] CbrFlag
        {
            get
            {
                uint[] __value = null;
                if (((global::h264bsd.HrdParametersT.__Internal*) __Instance)->cbrFlag != null)
                {
                    __value = new uint[32];
                    for (int i = 0; i < 32; i++)
                        __value[i] = ((global::h264bsd.HrdParametersT.__Internal*) __Instance)->cbrFlag[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((global::h264bsd.HrdParametersT.__Internal*)__Instance)->cbrFlag[i] = value[i];
                }
            }
        }

        public uint InitialCpbRemovalDelayLength
        {
            get
            {
                return ((global::h264bsd.HrdParametersT.__Internal*) __Instance)->initialCpbRemovalDelayLength;
            }

            set
            {
                ((global::h264bsd.HrdParametersT.__Internal*)__Instance)->initialCpbRemovalDelayLength = value;
            }
        }

        public uint CpbRemovalDelayLength
        {
            get
            {
                return ((global::h264bsd.HrdParametersT.__Internal*) __Instance)->cpbRemovalDelayLength;
            }

            set
            {
                ((global::h264bsd.HrdParametersT.__Internal*)__Instance)->cpbRemovalDelayLength = value;
            }
        }

        public uint DpbOutputDelayLength
        {
            get
            {
                return ((global::h264bsd.HrdParametersT.__Internal*) __Instance)->dpbOutputDelayLength;
            }

            set
            {
                ((global::h264bsd.HrdParametersT.__Internal*)__Instance)->dpbOutputDelayLength = value;
            }
        }

        public uint TimeOffsetLength
        {
            get
            {
                return ((global::h264bsd.HrdParametersT.__Internal*) __Instance)->timeOffsetLength;
            }

            set
            {
                ((global::h264bsd.HrdParametersT.__Internal*)__Instance)->timeOffsetLength = value;
            }
        }
    }

    public unsafe partial class VuiParametersT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 952)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint aspectRatioPresentFlag;

            [FieldOffset(4)]
            internal uint aspectRatioIdc;

            [FieldOffset(8)]
            internal uint sarWidth;

            [FieldOffset(12)]
            internal uint sarHeight;

            [FieldOffset(16)]
            internal uint overscanInfoPresentFlag;

            [FieldOffset(20)]
            internal uint overscanAppropriateFlag;

            [FieldOffset(24)]
            internal uint videoSignalTypePresentFlag;

            [FieldOffset(28)]
            internal uint videoFormat;

            [FieldOffset(32)]
            internal uint videoFullRangeFlag;

            [FieldOffset(36)]
            internal uint colourDescriptionPresentFlag;

            [FieldOffset(40)]
            internal uint colourPrimaries;

            [FieldOffset(44)]
            internal uint transferCharacteristics;

            [FieldOffset(48)]
            internal uint matrixCoefficients;

            [FieldOffset(52)]
            internal uint chromaLocInfoPresentFlag;

            [FieldOffset(56)]
            internal uint chromaSampleLocTypeTopField;

            [FieldOffset(60)]
            internal uint chromaSampleLocTypeBottomField;

            [FieldOffset(64)]
            internal uint timingInfoPresentFlag;

            [FieldOffset(68)]
            internal uint numUnitsInTick;

            [FieldOffset(72)]
            internal uint timeScale;

            [FieldOffset(76)]
            internal uint fixedFrameRateFlag;

            [FieldOffset(80)]
            internal uint nalHrdParametersPresentFlag;

            [FieldOffset(84)]
            internal global::h264bsd.HrdParametersT.__Internal nalHrdParameters;

            [FieldOffset(496)]
            internal uint vclHrdParametersPresentFlag;

            [FieldOffset(500)]
            internal global::h264bsd.HrdParametersT.__Internal vclHrdParameters;

            [FieldOffset(912)]
            internal uint lowDelayHrdFlag;

            [FieldOffset(916)]
            internal uint picStructPresentFlag;

            [FieldOffset(920)]
            internal uint bitstreamRestrictionFlag;

            [FieldOffset(924)]
            internal uint motionVectorsOverPicBoundariesFlag;

            [FieldOffset(928)]
            internal uint maxBytesPerPicDenom;

            [FieldOffset(932)]
            internal uint maxBitsPerMbDenom;

            [FieldOffset(936)]
            internal uint log2MaxMvLengthHorizontal;

            [FieldOffset(940)]
            internal uint log2MaxMvLengthVertical;

            [FieldOffset(944)]
            internal uint numReorderFrames;

            [FieldOffset(948)]
            internal uint maxDecFrameBuffering;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0vuiParameters_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.VuiParametersT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.VuiParametersT>();

        protected bool __ownsNativeInstance;

        internal static global::h264bsd.VuiParametersT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::h264bsd.VuiParametersT(native.ToPointer(), skipVTables);
        }

        internal static global::h264bsd.VuiParametersT __CreateInstance(global::h264bsd.VuiParametersT.__Internal native, bool skipVTables = false)
        {
            return new global::h264bsd.VuiParametersT(native, skipVTables);
        }

        private static void* __CopyValue(global::h264bsd.VuiParametersT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::h264bsd.VuiParametersT.__Internal));
            *(global::h264bsd.VuiParametersT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VuiParametersT(global::h264bsd.VuiParametersT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected VuiParametersT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public VuiParametersT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.VuiParametersT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public VuiParametersT(global::h264bsd.VuiParametersT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.VuiParametersT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::h264bsd.VuiParametersT.__Internal*) __Instance) = *((global::h264bsd.VuiParametersT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::h264bsd.VuiParametersT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint AspectRatioPresentFlag
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->aspectRatioPresentFlag;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->aspectRatioPresentFlag = value;
            }
        }

        public uint AspectRatioIdc
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->aspectRatioIdc;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->aspectRatioIdc = value;
            }
        }

        public uint SarWidth
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->sarWidth;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->sarWidth = value;
            }
        }

        public uint SarHeight
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->sarHeight;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->sarHeight = value;
            }
        }

        public uint OverscanInfoPresentFlag
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->overscanInfoPresentFlag;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->overscanInfoPresentFlag = value;
            }
        }

        public uint OverscanAppropriateFlag
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->overscanAppropriateFlag;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->overscanAppropriateFlag = value;
            }
        }

        public uint VideoSignalTypePresentFlag
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->videoSignalTypePresentFlag;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->videoSignalTypePresentFlag = value;
            }
        }

        public uint VideoFormat
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->videoFormat;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->videoFormat = value;
            }
        }

        public uint VideoFullRangeFlag
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->videoFullRangeFlag;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->videoFullRangeFlag = value;
            }
        }

        public uint ColourDescriptionPresentFlag
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->colourDescriptionPresentFlag;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->colourDescriptionPresentFlag = value;
            }
        }

        public uint ColourPrimaries
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->colourPrimaries;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->colourPrimaries = value;
            }
        }

        public uint TransferCharacteristics
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->transferCharacteristics;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->transferCharacteristics = value;
            }
        }

        public uint MatrixCoefficients
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->matrixCoefficients;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->matrixCoefficients = value;
            }
        }

        public uint ChromaLocInfoPresentFlag
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->chromaLocInfoPresentFlag;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->chromaLocInfoPresentFlag = value;
            }
        }

        public uint ChromaSampleLocTypeTopField
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->chromaSampleLocTypeTopField;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->chromaSampleLocTypeTopField = value;
            }
        }

        public uint ChromaSampleLocTypeBottomField
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->chromaSampleLocTypeBottomField;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->chromaSampleLocTypeBottomField = value;
            }
        }

        public uint TimingInfoPresentFlag
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->timingInfoPresentFlag;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->timingInfoPresentFlag = value;
            }
        }

        public uint NumUnitsInTick
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->numUnitsInTick;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->numUnitsInTick = value;
            }
        }

        public uint TimeScale
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->timeScale;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->timeScale = value;
            }
        }

        public uint FixedFrameRateFlag
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->fixedFrameRateFlag;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->fixedFrameRateFlag = value;
            }
        }

        public uint NalHrdParametersPresentFlag
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->nalHrdParametersPresentFlag;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->nalHrdParametersPresentFlag = value;
            }
        }

        public global::h264bsd.HrdParametersT NalHrdParameters
        {
            get
            {
                return global::h264bsd.HrdParametersT.__CreateInstance(new global::System.IntPtr(&((global::h264bsd.VuiParametersT.__Internal*) __Instance)->nalHrdParameters));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->nalHrdParameters = *(global::h264bsd.HrdParametersT.__Internal*) value.__Instance;
            }
        }

        public uint VclHrdParametersPresentFlag
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->vclHrdParametersPresentFlag;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->vclHrdParametersPresentFlag = value;
            }
        }

        public global::h264bsd.HrdParametersT VclHrdParameters
        {
            get
            {
                return global::h264bsd.HrdParametersT.__CreateInstance(new global::System.IntPtr(&((global::h264bsd.VuiParametersT.__Internal*) __Instance)->vclHrdParameters));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->vclHrdParameters = *(global::h264bsd.HrdParametersT.__Internal*) value.__Instance;
            }
        }

        public uint LowDelayHrdFlag
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->lowDelayHrdFlag;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->lowDelayHrdFlag = value;
            }
        }

        public uint PicStructPresentFlag
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->picStructPresentFlag;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->picStructPresentFlag = value;
            }
        }

        public uint BitstreamRestrictionFlag
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->bitstreamRestrictionFlag;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->bitstreamRestrictionFlag = value;
            }
        }

        public uint MotionVectorsOverPicBoundariesFlag
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->motionVectorsOverPicBoundariesFlag;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->motionVectorsOverPicBoundariesFlag = value;
            }
        }

        public uint MaxBytesPerPicDenom
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->maxBytesPerPicDenom;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->maxBytesPerPicDenom = value;
            }
        }

        public uint MaxBitsPerMbDenom
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->maxBitsPerMbDenom;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->maxBitsPerMbDenom = value;
            }
        }

        public uint Log2MaxMvLengthHorizontal
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->log2MaxMvLengthHorizontal;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->log2MaxMvLengthHorizontal = value;
            }
        }

        public uint Log2MaxMvLengthVertical
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->log2MaxMvLengthVertical;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->log2MaxMvLengthVertical = value;
            }
        }

        public uint NumReorderFrames
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->numReorderFrames;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->numReorderFrames = value;
            }
        }

        public uint MaxDecFrameBuffering
        {
            get
            {
                return ((global::h264bsd.VuiParametersT.__Internal*) __Instance)->maxDecFrameBuffering;
            }

            set
            {
                ((global::h264bsd.VuiParametersT.__Internal*)__Instance)->maxDecFrameBuffering = value;
            }
        }
    }

    public unsafe partial class h264bsd_vui
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdDecodeVuiParameters@@YAIPEAUstrmData_t@@PEAUvuiParameters_t@@@Z")]
            internal static extern uint H264bsdDecodeVuiParameters(global::System.IntPtr pStrmData, global::System.IntPtr pVuiParameters);
        }

        public static uint H264bsdDecodeVuiParameters(global::h264bsd.StrmDataT pStrmData, global::h264bsd.VuiParametersT pVuiParameters)
        {
            var __arg0 = ReferenceEquals(pStrmData, null) ? global::System.IntPtr.Zero : pStrmData.__Instance;
            var __arg1 = ReferenceEquals(pVuiParameters, null) ? global::System.IntPtr.Zero : pVuiParameters.__Instance;
            var __ret = __Internal.H264bsdDecodeVuiParameters(__arg0, __arg1);
            return __ret;
        }
    }

    public enum NalUnitTypeE
    {
        NAL_CODED_SLICE = 1,
        NAL_CODED_SLICE_IDR = 5,
        NAL_SEI = 6,
        NAL_SEQ_PARAM_SET = 7,
        NAL_PIC_PARAM_SET = 8,
        NAL_ACCESS_UNIT_DELIMITER = 9,
        NAL_END_OF_SEQUENCE = 10,
        NAL_END_OF_STREAM = 11,
        NAL_FILLER_DATA = 12,
        NAL_MAX_TYPE_VALUE = 31
    }

    public unsafe partial class NalUnitT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::h264bsd.NalUnitTypeE nalUnitType;

            [FieldOffset(4)]
            internal uint nalRefIdc;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0nalUnit_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.NalUnitT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.NalUnitT>();

        protected bool __ownsNativeInstance;

        internal static global::h264bsd.NalUnitT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::h264bsd.NalUnitT(native.ToPointer(), skipVTables);
        }

        internal static global::h264bsd.NalUnitT __CreateInstance(global::h264bsd.NalUnitT.__Internal native, bool skipVTables = false)
        {
            return new global::h264bsd.NalUnitT(native, skipVTables);
        }

        private static void* __CopyValue(global::h264bsd.NalUnitT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::h264bsd.NalUnitT.__Internal));
            *(global::h264bsd.NalUnitT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private NalUnitT(global::h264bsd.NalUnitT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected NalUnitT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public NalUnitT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.NalUnitT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public NalUnitT(global::h264bsd.NalUnitT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.NalUnitT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::h264bsd.NalUnitT.__Internal*) __Instance) = *((global::h264bsd.NalUnitT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::h264bsd.NalUnitT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::h264bsd.NalUnitTypeE NalUnitType
        {
            get
            {
                return ((global::h264bsd.NalUnitT.__Internal*) __Instance)->nalUnitType;
            }

            set
            {
                ((global::h264bsd.NalUnitT.__Internal*)__Instance)->nalUnitType = value;
            }
        }

        public uint NalRefIdc
        {
            get
            {
                return ((global::h264bsd.NalUnitT.__Internal*) __Instance)->nalRefIdc;
            }

            set
            {
                ((global::h264bsd.NalUnitT.__Internal*)__Instance)->nalRefIdc = value;
            }
        }
    }

    public unsafe partial class h264bsd_nal_unit
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdDecodeNalUnit@@YAIPEAUstrmData_t@@PEAUnalUnit_t@@@Z")]
            internal static extern uint H264bsdDecodeNalUnit(global::System.IntPtr pStrmData, global::System.IntPtr pNalUnit);
        }

        public static uint H264bsdDecodeNalUnit(global::h264bsd.StrmDataT pStrmData, global::h264bsd.NalUnitT pNalUnit)
        {
            var __arg0 = ReferenceEquals(pStrmData, null) ? global::System.IntPtr.Zero : pStrmData.__Instance;
            var __arg1 = ReferenceEquals(pNalUnit, null) ? global::System.IntPtr.Zero : pNalUnit.__Instance;
            var __ret = __Internal.H264bsdDecodeNalUnit(__arg0, __arg1);
            return __ret;
        }
    }

    public enum _0
    {
        P_SLICE = 0,
        I_SLICE = 2
    }

    public enum NO_LONG_TERM_FRAME_INDICES
    {
        NO_LONG_TERM_FRAME_INDICES = 65535
    }

    public unsafe partial class RefPicListReorderingOperationT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint reorderingOfPicNumsIdc;

            [FieldOffset(4)]
            internal uint absDiffPicNum;

            [FieldOffset(8)]
            internal uint longTermPicNum;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0refPicListReorderingOperation_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.RefPicListReorderingOperationT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.RefPicListReorderingOperationT>();

        protected bool __ownsNativeInstance;

        internal static global::h264bsd.RefPicListReorderingOperationT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::h264bsd.RefPicListReorderingOperationT(native.ToPointer(), skipVTables);
        }

        internal static global::h264bsd.RefPicListReorderingOperationT __CreateInstance(global::h264bsd.RefPicListReorderingOperationT.__Internal native, bool skipVTables = false)
        {
            return new global::h264bsd.RefPicListReorderingOperationT(native, skipVTables);
        }

        private static void* __CopyValue(global::h264bsd.RefPicListReorderingOperationT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::h264bsd.RefPicListReorderingOperationT.__Internal));
            *(global::h264bsd.RefPicListReorderingOperationT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RefPicListReorderingOperationT(global::h264bsd.RefPicListReorderingOperationT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RefPicListReorderingOperationT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public RefPicListReorderingOperationT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.RefPicListReorderingOperationT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RefPicListReorderingOperationT(global::h264bsd.RefPicListReorderingOperationT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.RefPicListReorderingOperationT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::h264bsd.RefPicListReorderingOperationT.__Internal*) __Instance) = *((global::h264bsd.RefPicListReorderingOperationT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::h264bsd.RefPicListReorderingOperationT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ReorderingOfPicNumsIdc
        {
            get
            {
                return ((global::h264bsd.RefPicListReorderingOperationT.__Internal*) __Instance)->reorderingOfPicNumsIdc;
            }

            set
            {
                ((global::h264bsd.RefPicListReorderingOperationT.__Internal*)__Instance)->reorderingOfPicNumsIdc = value;
            }
        }

        public uint AbsDiffPicNum
        {
            get
            {
                return ((global::h264bsd.RefPicListReorderingOperationT.__Internal*) __Instance)->absDiffPicNum;
            }

            set
            {
                ((global::h264bsd.RefPicListReorderingOperationT.__Internal*)__Instance)->absDiffPicNum = value;
            }
        }

        public uint LongTermPicNum
        {
            get
            {
                return ((global::h264bsd.RefPicListReorderingOperationT.__Internal*) __Instance)->longTermPicNum;
            }

            set
            {
                ((global::h264bsd.RefPicListReorderingOperationT.__Internal*)__Instance)->longTermPicNum = value;
            }
        }
    }

    public unsafe partial class RefPicListReorderingT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 208)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint refPicListReorderingFlagL0;

            [FieldOffset(4)]
            internal fixed byte command[204];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0refPicListReordering_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.RefPicListReorderingT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.RefPicListReorderingT>();

        protected bool __ownsNativeInstance;

        internal static global::h264bsd.RefPicListReorderingT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::h264bsd.RefPicListReorderingT(native.ToPointer(), skipVTables);
        }

        internal static global::h264bsd.RefPicListReorderingT __CreateInstance(global::h264bsd.RefPicListReorderingT.__Internal native, bool skipVTables = false)
        {
            return new global::h264bsd.RefPicListReorderingT(native, skipVTables);
        }

        private static void* __CopyValue(global::h264bsd.RefPicListReorderingT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::h264bsd.RefPicListReorderingT.__Internal));
            *(global::h264bsd.RefPicListReorderingT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RefPicListReorderingT(global::h264bsd.RefPicListReorderingT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RefPicListReorderingT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public RefPicListReorderingT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.RefPicListReorderingT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RefPicListReorderingT(global::h264bsd.RefPicListReorderingT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.RefPicListReorderingT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::h264bsd.RefPicListReorderingT.__Internal*) __Instance) = *((global::h264bsd.RefPicListReorderingT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::h264bsd.RefPicListReorderingT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint RefPicListReorderingFlagL0
        {
            get
            {
                return ((global::h264bsd.RefPicListReorderingT.__Internal*) __Instance)->refPicListReorderingFlagL0;
            }

            set
            {
                ((global::h264bsd.RefPicListReorderingT.__Internal*)__Instance)->refPicListReorderingFlagL0 = value;
            }
        }

        public global::h264bsd.RefPicListReorderingOperationT[] Command
        {
            get
            {
                global::h264bsd.RefPicListReorderingOperationT[] __value = null;
                if (((global::h264bsd.RefPicListReorderingT.__Internal*) __Instance)->command != null)
                {
                    __value = new global::h264bsd.RefPicListReorderingOperationT[17];
                    for (int i = 0; i < 17; i++)
                        __value[i] = global::h264bsd.RefPicListReorderingOperationT.__CreateInstance(*((global::h264bsd.RefPicListReorderingOperationT.__Internal*)&(((global::h264bsd.RefPicListReorderingT.__Internal*) __Instance)->command[i * sizeof(global::h264bsd.RefPicListReorderingOperationT.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 17)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 17; i++)
                        *(global::h264bsd.RefPicListReorderingOperationT.__Internal*) &((global::h264bsd.RefPicListReorderingT.__Internal*)__Instance)->command[i * sizeof(global::h264bsd.RefPicListReorderingOperationT.__Internal)] = *(global::h264bsd.RefPicListReorderingOperationT.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    public unsafe partial class MemoryManagementOperationT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint memoryManagementControlOperation;

            [FieldOffset(4)]
            internal uint differenceOfPicNums;

            [FieldOffset(8)]
            internal uint longTermPicNum;

            [FieldOffset(12)]
            internal uint longTermFrameIdx;

            [FieldOffset(16)]
            internal uint maxLongTermFrameIdx;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0memoryManagementOperation_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.MemoryManagementOperationT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.MemoryManagementOperationT>();

        protected bool __ownsNativeInstance;

        internal static global::h264bsd.MemoryManagementOperationT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::h264bsd.MemoryManagementOperationT(native.ToPointer(), skipVTables);
        }

        internal static global::h264bsd.MemoryManagementOperationT __CreateInstance(global::h264bsd.MemoryManagementOperationT.__Internal native, bool skipVTables = false)
        {
            return new global::h264bsd.MemoryManagementOperationT(native, skipVTables);
        }

        private static void* __CopyValue(global::h264bsd.MemoryManagementOperationT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::h264bsd.MemoryManagementOperationT.__Internal));
            *(global::h264bsd.MemoryManagementOperationT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MemoryManagementOperationT(global::h264bsd.MemoryManagementOperationT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MemoryManagementOperationT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MemoryManagementOperationT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.MemoryManagementOperationT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MemoryManagementOperationT(global::h264bsd.MemoryManagementOperationT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.MemoryManagementOperationT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::h264bsd.MemoryManagementOperationT.__Internal*) __Instance) = *((global::h264bsd.MemoryManagementOperationT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::h264bsd.MemoryManagementOperationT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint MemoryManagementControlOperation
        {
            get
            {
                return ((global::h264bsd.MemoryManagementOperationT.__Internal*) __Instance)->memoryManagementControlOperation;
            }

            set
            {
                ((global::h264bsd.MemoryManagementOperationT.__Internal*)__Instance)->memoryManagementControlOperation = value;
            }
        }

        public uint DifferenceOfPicNums
        {
            get
            {
                return ((global::h264bsd.MemoryManagementOperationT.__Internal*) __Instance)->differenceOfPicNums;
            }

            set
            {
                ((global::h264bsd.MemoryManagementOperationT.__Internal*)__Instance)->differenceOfPicNums = value;
            }
        }

        public uint LongTermPicNum
        {
            get
            {
                return ((global::h264bsd.MemoryManagementOperationT.__Internal*) __Instance)->longTermPicNum;
            }

            set
            {
                ((global::h264bsd.MemoryManagementOperationT.__Internal*)__Instance)->longTermPicNum = value;
            }
        }

        public uint LongTermFrameIdx
        {
            get
            {
                return ((global::h264bsd.MemoryManagementOperationT.__Internal*) __Instance)->longTermFrameIdx;
            }

            set
            {
                ((global::h264bsd.MemoryManagementOperationT.__Internal*)__Instance)->longTermFrameIdx = value;
            }
        }

        public uint MaxLongTermFrameIdx
        {
            get
            {
                return ((global::h264bsd.MemoryManagementOperationT.__Internal*) __Instance)->maxLongTermFrameIdx;
            }

            set
            {
                ((global::h264bsd.MemoryManagementOperationT.__Internal*)__Instance)->maxLongTermFrameIdx = value;
            }
        }
    }

    public unsafe partial class DecRefPicMarkingT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 712)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint noOutputOfPriorPicsFlag;

            [FieldOffset(4)]
            internal uint longTermReferenceFlag;

            [FieldOffset(8)]
            internal uint adaptiveRefPicMarkingModeFlag;

            [FieldOffset(12)]
            internal fixed byte operation[700];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0decRefPicMarking_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.DecRefPicMarkingT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.DecRefPicMarkingT>();

        protected bool __ownsNativeInstance;

        internal static global::h264bsd.DecRefPicMarkingT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::h264bsd.DecRefPicMarkingT(native.ToPointer(), skipVTables);
        }

        internal static global::h264bsd.DecRefPicMarkingT __CreateInstance(global::h264bsd.DecRefPicMarkingT.__Internal native, bool skipVTables = false)
        {
            return new global::h264bsd.DecRefPicMarkingT(native, skipVTables);
        }

        private static void* __CopyValue(global::h264bsd.DecRefPicMarkingT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::h264bsd.DecRefPicMarkingT.__Internal));
            *(global::h264bsd.DecRefPicMarkingT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DecRefPicMarkingT(global::h264bsd.DecRefPicMarkingT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DecRefPicMarkingT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public DecRefPicMarkingT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.DecRefPicMarkingT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public DecRefPicMarkingT(global::h264bsd.DecRefPicMarkingT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.DecRefPicMarkingT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::h264bsd.DecRefPicMarkingT.__Internal*) __Instance) = *((global::h264bsd.DecRefPicMarkingT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::h264bsd.DecRefPicMarkingT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint NoOutputOfPriorPicsFlag
        {
            get
            {
                return ((global::h264bsd.DecRefPicMarkingT.__Internal*) __Instance)->noOutputOfPriorPicsFlag;
            }

            set
            {
                ((global::h264bsd.DecRefPicMarkingT.__Internal*)__Instance)->noOutputOfPriorPicsFlag = value;
            }
        }

        public uint LongTermReferenceFlag
        {
            get
            {
                return ((global::h264bsd.DecRefPicMarkingT.__Internal*) __Instance)->longTermReferenceFlag;
            }

            set
            {
                ((global::h264bsd.DecRefPicMarkingT.__Internal*)__Instance)->longTermReferenceFlag = value;
            }
        }

        public uint AdaptiveRefPicMarkingModeFlag
        {
            get
            {
                return ((global::h264bsd.DecRefPicMarkingT.__Internal*) __Instance)->adaptiveRefPicMarkingModeFlag;
            }

            set
            {
                ((global::h264bsd.DecRefPicMarkingT.__Internal*)__Instance)->adaptiveRefPicMarkingModeFlag = value;
            }
        }

        public global::h264bsd.MemoryManagementOperationT[] Operation
        {
            get
            {
                global::h264bsd.MemoryManagementOperationT[] __value = null;
                if (((global::h264bsd.DecRefPicMarkingT.__Internal*) __Instance)->operation != null)
                {
                    __value = new global::h264bsd.MemoryManagementOperationT[35];
                    for (int i = 0; i < 35; i++)
                        __value[i] = global::h264bsd.MemoryManagementOperationT.__CreateInstance(*((global::h264bsd.MemoryManagementOperationT.__Internal*)&(((global::h264bsd.DecRefPicMarkingT.__Internal*) __Instance)->operation[i * sizeof(global::h264bsd.MemoryManagementOperationT.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 35)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 35; i++)
                        *(global::h264bsd.MemoryManagementOperationT.__Internal*) &((global::h264bsd.DecRefPicMarkingT.__Internal*)__Instance)->operation[i * sizeof(global::h264bsd.MemoryManagementOperationT.__Internal)] = *(global::h264bsd.MemoryManagementOperationT.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    public unsafe partial class SliceHeaderT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 988)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint firstMbInSlice;

            [FieldOffset(4)]
            internal uint sliceType;

            [FieldOffset(8)]
            internal uint picParameterSetId;

            [FieldOffset(12)]
            internal uint frameNum;

            [FieldOffset(16)]
            internal uint idrPicId;

            [FieldOffset(20)]
            internal uint picOrderCntLsb;

            [FieldOffset(24)]
            internal int deltaPicOrderCntBottom;

            [FieldOffset(28)]
            internal fixed int deltaPicOrderCnt[2];

            [FieldOffset(36)]
            internal uint redundantPicCnt;

            [FieldOffset(40)]
            internal uint numRefIdxActiveOverrideFlag;

            [FieldOffset(44)]
            internal uint numRefIdxL0Active;

            [FieldOffset(48)]
            internal int sliceQpDelta;

            [FieldOffset(52)]
            internal uint disableDeblockingFilterIdc;

            [FieldOffset(56)]
            internal int sliceAlphaC0Offset;

            [FieldOffset(60)]
            internal int sliceBetaOffset;

            [FieldOffset(64)]
            internal uint sliceGroupChangeCycle;

            [FieldOffset(68)]
            internal global::h264bsd.RefPicListReorderingT.__Internal refPicListReordering;

            [FieldOffset(276)]
            internal global::h264bsd.DecRefPicMarkingT.__Internal decRefPicMarking;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0sliceHeader_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.SliceHeaderT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.SliceHeaderT>();

        protected bool __ownsNativeInstance;

        internal static global::h264bsd.SliceHeaderT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::h264bsd.SliceHeaderT(native.ToPointer(), skipVTables);
        }

        internal static global::h264bsd.SliceHeaderT __CreateInstance(global::h264bsd.SliceHeaderT.__Internal native, bool skipVTables = false)
        {
            return new global::h264bsd.SliceHeaderT(native, skipVTables);
        }

        private static void* __CopyValue(global::h264bsd.SliceHeaderT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::h264bsd.SliceHeaderT.__Internal));
            *(global::h264bsd.SliceHeaderT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SliceHeaderT(global::h264bsd.SliceHeaderT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SliceHeaderT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public SliceHeaderT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.SliceHeaderT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SliceHeaderT(global::h264bsd.SliceHeaderT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.SliceHeaderT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::h264bsd.SliceHeaderT.__Internal*) __Instance) = *((global::h264bsd.SliceHeaderT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::h264bsd.SliceHeaderT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint FirstMbInSlice
        {
            get
            {
                return ((global::h264bsd.SliceHeaderT.__Internal*) __Instance)->firstMbInSlice;
            }

            set
            {
                ((global::h264bsd.SliceHeaderT.__Internal*)__Instance)->firstMbInSlice = value;
            }
        }

        public uint SliceType
        {
            get
            {
                return ((global::h264bsd.SliceHeaderT.__Internal*) __Instance)->sliceType;
            }

            set
            {
                ((global::h264bsd.SliceHeaderT.__Internal*)__Instance)->sliceType = value;
            }
        }

        public uint PicParameterSetId
        {
            get
            {
                return ((global::h264bsd.SliceHeaderT.__Internal*) __Instance)->picParameterSetId;
            }

            set
            {
                ((global::h264bsd.SliceHeaderT.__Internal*)__Instance)->picParameterSetId = value;
            }
        }

        public uint FrameNum
        {
            get
            {
                return ((global::h264bsd.SliceHeaderT.__Internal*) __Instance)->frameNum;
            }

            set
            {
                ((global::h264bsd.SliceHeaderT.__Internal*)__Instance)->frameNum = value;
            }
        }

        public uint IdrPicId
        {
            get
            {
                return ((global::h264bsd.SliceHeaderT.__Internal*) __Instance)->idrPicId;
            }

            set
            {
                ((global::h264bsd.SliceHeaderT.__Internal*)__Instance)->idrPicId = value;
            }
        }

        public uint PicOrderCntLsb
        {
            get
            {
                return ((global::h264bsd.SliceHeaderT.__Internal*) __Instance)->picOrderCntLsb;
            }

            set
            {
                ((global::h264bsd.SliceHeaderT.__Internal*)__Instance)->picOrderCntLsb = value;
            }
        }

        public int DeltaPicOrderCntBottom
        {
            get
            {
                return ((global::h264bsd.SliceHeaderT.__Internal*) __Instance)->deltaPicOrderCntBottom;
            }

            set
            {
                ((global::h264bsd.SliceHeaderT.__Internal*)__Instance)->deltaPicOrderCntBottom = value;
            }
        }

        public int[] DeltaPicOrderCnt
        {
            get
            {
                int[] __value = null;
                if (((global::h264bsd.SliceHeaderT.__Internal*) __Instance)->deltaPicOrderCnt != null)
                {
                    __value = new int[2];
                    for (int i = 0; i < 2; i++)
                        __value[i] = ((global::h264bsd.SliceHeaderT.__Internal*) __Instance)->deltaPicOrderCnt[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((global::h264bsd.SliceHeaderT.__Internal*)__Instance)->deltaPicOrderCnt[i] = value[i];
                }
            }
        }

        public uint RedundantPicCnt
        {
            get
            {
                return ((global::h264bsd.SliceHeaderT.__Internal*) __Instance)->redundantPicCnt;
            }

            set
            {
                ((global::h264bsd.SliceHeaderT.__Internal*)__Instance)->redundantPicCnt = value;
            }
        }

        public uint NumRefIdxActiveOverrideFlag
        {
            get
            {
                return ((global::h264bsd.SliceHeaderT.__Internal*) __Instance)->numRefIdxActiveOverrideFlag;
            }

            set
            {
                ((global::h264bsd.SliceHeaderT.__Internal*)__Instance)->numRefIdxActiveOverrideFlag = value;
            }
        }

        public uint NumRefIdxL0Active
        {
            get
            {
                return ((global::h264bsd.SliceHeaderT.__Internal*) __Instance)->numRefIdxL0Active;
            }

            set
            {
                ((global::h264bsd.SliceHeaderT.__Internal*)__Instance)->numRefIdxL0Active = value;
            }
        }

        public int SliceQpDelta
        {
            get
            {
                return ((global::h264bsd.SliceHeaderT.__Internal*) __Instance)->sliceQpDelta;
            }

            set
            {
                ((global::h264bsd.SliceHeaderT.__Internal*)__Instance)->sliceQpDelta = value;
            }
        }

        public uint DisableDeblockingFilterIdc
        {
            get
            {
                return ((global::h264bsd.SliceHeaderT.__Internal*) __Instance)->disableDeblockingFilterIdc;
            }

            set
            {
                ((global::h264bsd.SliceHeaderT.__Internal*)__Instance)->disableDeblockingFilterIdc = value;
            }
        }

        public int SliceAlphaC0Offset
        {
            get
            {
                return ((global::h264bsd.SliceHeaderT.__Internal*) __Instance)->sliceAlphaC0Offset;
            }

            set
            {
                ((global::h264bsd.SliceHeaderT.__Internal*)__Instance)->sliceAlphaC0Offset = value;
            }
        }

        public int SliceBetaOffset
        {
            get
            {
                return ((global::h264bsd.SliceHeaderT.__Internal*) __Instance)->sliceBetaOffset;
            }

            set
            {
                ((global::h264bsd.SliceHeaderT.__Internal*)__Instance)->sliceBetaOffset = value;
            }
        }

        public uint SliceGroupChangeCycle
        {
            get
            {
                return ((global::h264bsd.SliceHeaderT.__Internal*) __Instance)->sliceGroupChangeCycle;
            }

            set
            {
                ((global::h264bsd.SliceHeaderT.__Internal*)__Instance)->sliceGroupChangeCycle = value;
            }
        }

        public global::h264bsd.RefPicListReorderingT RefPicListReordering
        {
            get
            {
                return global::h264bsd.RefPicListReorderingT.__CreateInstance(new global::System.IntPtr(&((global::h264bsd.SliceHeaderT.__Internal*) __Instance)->refPicListReordering));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::h264bsd.SliceHeaderT.__Internal*)__Instance)->refPicListReordering = *(global::h264bsd.RefPicListReorderingT.__Internal*) value.__Instance;
            }
        }

        public global::h264bsd.DecRefPicMarkingT DecRefPicMarking
        {
            get
            {
                return global::h264bsd.DecRefPicMarkingT.__CreateInstance(new global::System.IntPtr(&((global::h264bsd.SliceHeaderT.__Internal*) __Instance)->decRefPicMarking));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::h264bsd.SliceHeaderT.__Internal*)__Instance)->decRefPicMarking = *(global::h264bsd.DecRefPicMarkingT.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class h264bsd_slice_header
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdDecodeSliceHeader@@YAIPEAUstrmData_t@@PEAUsliceHeader_t@@PEAUseqParamSet_t@@PEAUpicParamSet_t@@PEAUnalUnit_t@@@Z")]
            internal static extern uint H264bsdDecodeSliceHeader(global::System.IntPtr pStrmData, global::System.IntPtr pSliceHeader, global::System.IntPtr pSeqParamSet, global::System.IntPtr pPicParamSet, global::System.IntPtr pNalUnit);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdCheckPpsId@@YAIPEAUstrmData_t@@PEAI@Z")]
            internal static extern uint H264bsdCheckPpsId(global::System.IntPtr pStrmData, uint* ppsId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdCheckFrameNum@@YAIPEAUstrmData_t@@IPEAI@Z")]
            internal static extern uint H264bsdCheckFrameNum(global::System.IntPtr pStrmData, uint maxFrameNum, uint* frameNum);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdCheckIdrPicId@@YAIPEAUstrmData_t@@IW4nalUnitType_e@@PEAI@Z")]
            internal static extern uint H264bsdCheckIdrPicId(global::System.IntPtr pStrmData, uint maxFrameNum, global::h264bsd.NalUnitTypeE nalUnitType, uint* idrPicId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdCheckPicOrderCntLsb@@YAIPEAUstrmData_t@@PEAUseqParamSet_t@@W4nalUnitType_e@@PEAI@Z")]
            internal static extern uint H264bsdCheckPicOrderCntLsb(global::System.IntPtr pStrmData, global::System.IntPtr pSeqParamSet, global::h264bsd.NalUnitTypeE nalUnitType, uint* picOrderCntLsb);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdCheckDeltaPicOrderCntBottom@@YAIPEAUstrmData_t@@PEAUseqParamSet_t@@W4nalUnitType_e@@PEAH@Z")]
            internal static extern uint H264bsdCheckDeltaPicOrderCntBottom(global::System.IntPtr pStrmData, global::System.IntPtr pSeqParamSet, global::h264bsd.NalUnitTypeE nalUnitType, int* deltaPicOrderCntBottom);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdCheckDeltaPicOrderCnt@@YAIPEAUstrmData_t@@PEAUseqParamSet_t@@W4nalUnitType_e@@IPEAH@Z")]
            internal static extern uint H264bsdCheckDeltaPicOrderCnt(global::System.IntPtr pStrmData, global::System.IntPtr pSeqParamSet, global::h264bsd.NalUnitTypeE nalUnitType, uint picOrderPresentFlag, int* deltaPicOrderCnt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdCheckRedundantPicCnt@@YAIPEAUstrmData_t@@PEAUseqParamSet_t@@PEAUpicParamSet_t@@W4nalUnitType_e@@PEAI@Z")]
            internal static extern uint H264bsdCheckRedundantPicCnt(global::System.IntPtr pStrmData, global::System.IntPtr pSeqParamSet, global::System.IntPtr pPicParamSet, global::h264bsd.NalUnitTypeE nalUnitType, uint* redundantPicCnt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdCheckPriorPicsFlag@@YAIPEAIPEBUstrmData_t@@PEBUseqParamSet_t@@PEBUpicParamSet_t@@W4nalUnitType_e@@@Z")]
            internal static extern uint H264bsdCheckPriorPicsFlag(uint* noOutputOfPriorPicsFlag, global::System.IntPtr pStrmData, global::System.IntPtr pSeqParamSet, global::System.IntPtr pPicParamSet, global::h264bsd.NalUnitTypeE nalUnitType);
        }

        public static uint H264bsdDecodeSliceHeader(global::h264bsd.StrmDataT pStrmData, global::h264bsd.SliceHeaderT pSliceHeader, global::h264bsd.SeqParamSetT pSeqParamSet, global::h264bsd.PicParamSetT pPicParamSet, global::h264bsd.NalUnitT pNalUnit)
        {
            var __arg0 = ReferenceEquals(pStrmData, null) ? global::System.IntPtr.Zero : pStrmData.__Instance;
            var __arg1 = ReferenceEquals(pSliceHeader, null) ? global::System.IntPtr.Zero : pSliceHeader.__Instance;
            var __arg2 = ReferenceEquals(pSeqParamSet, null) ? global::System.IntPtr.Zero : pSeqParamSet.__Instance;
            var __arg3 = ReferenceEquals(pPicParamSet, null) ? global::System.IntPtr.Zero : pPicParamSet.__Instance;
            var __arg4 = ReferenceEquals(pNalUnit, null) ? global::System.IntPtr.Zero : pNalUnit.__Instance;
            var __ret = __Internal.H264bsdDecodeSliceHeader(__arg0, __arg1, __arg2, __arg3, __arg4);
            return __ret;
        }

        public static uint H264bsdCheckPpsId(global::h264bsd.StrmDataT pStrmData, ref uint ppsId)
        {
            var __arg0 = ReferenceEquals(pStrmData, null) ? global::System.IntPtr.Zero : pStrmData.__Instance;
            fixed (uint* __ppsId1 = &ppsId)
            {
                var __arg1 = __ppsId1;
                var __ret = __Internal.H264bsdCheckPpsId(__arg0, __arg1);
                return __ret;
            }
        }

        public static uint H264bsdCheckFrameNum(global::h264bsd.StrmDataT pStrmData, uint maxFrameNum, ref uint frameNum)
        {
            var __arg0 = ReferenceEquals(pStrmData, null) ? global::System.IntPtr.Zero : pStrmData.__Instance;
            fixed (uint* __frameNum2 = &frameNum)
            {
                var __arg2 = __frameNum2;
                var __ret = __Internal.H264bsdCheckFrameNum(__arg0, maxFrameNum, __arg2);
                return __ret;
            }
        }

        public static uint H264bsdCheckIdrPicId(global::h264bsd.StrmDataT pStrmData, uint maxFrameNum, global::h264bsd.NalUnitTypeE nalUnitType, ref uint idrPicId)
        {
            var __arg0 = ReferenceEquals(pStrmData, null) ? global::System.IntPtr.Zero : pStrmData.__Instance;
            fixed (uint* __idrPicId3 = &idrPicId)
            {
                var __arg3 = __idrPicId3;
                var __ret = __Internal.H264bsdCheckIdrPicId(__arg0, maxFrameNum, nalUnitType, __arg3);
                return __ret;
            }
        }

        public static uint H264bsdCheckPicOrderCntLsb(global::h264bsd.StrmDataT pStrmData, global::h264bsd.SeqParamSetT pSeqParamSet, global::h264bsd.NalUnitTypeE nalUnitType, ref uint picOrderCntLsb)
        {
            var __arg0 = ReferenceEquals(pStrmData, null) ? global::System.IntPtr.Zero : pStrmData.__Instance;
            var __arg1 = ReferenceEquals(pSeqParamSet, null) ? global::System.IntPtr.Zero : pSeqParamSet.__Instance;
            fixed (uint* __picOrderCntLsb3 = &picOrderCntLsb)
            {
                var __arg3 = __picOrderCntLsb3;
                var __ret = __Internal.H264bsdCheckPicOrderCntLsb(__arg0, __arg1, nalUnitType, __arg3);
                return __ret;
            }
        }

        public static uint H264bsdCheckDeltaPicOrderCntBottom(global::h264bsd.StrmDataT pStrmData, global::h264bsd.SeqParamSetT pSeqParamSet, global::h264bsd.NalUnitTypeE nalUnitType, ref int deltaPicOrderCntBottom)
        {
            var __arg0 = ReferenceEquals(pStrmData, null) ? global::System.IntPtr.Zero : pStrmData.__Instance;
            var __arg1 = ReferenceEquals(pSeqParamSet, null) ? global::System.IntPtr.Zero : pSeqParamSet.__Instance;
            fixed (int* __deltaPicOrderCntBottom3 = &deltaPicOrderCntBottom)
            {
                var __arg3 = __deltaPicOrderCntBottom3;
                var __ret = __Internal.H264bsdCheckDeltaPicOrderCntBottom(__arg0, __arg1, nalUnitType, __arg3);
                return __ret;
            }
        }

        public static uint H264bsdCheckDeltaPicOrderCnt(global::h264bsd.StrmDataT pStrmData, global::h264bsd.SeqParamSetT pSeqParamSet, global::h264bsd.NalUnitTypeE nalUnitType, uint picOrderPresentFlag, ref int deltaPicOrderCnt)
        {
            var __arg0 = ReferenceEquals(pStrmData, null) ? global::System.IntPtr.Zero : pStrmData.__Instance;
            var __arg1 = ReferenceEquals(pSeqParamSet, null) ? global::System.IntPtr.Zero : pSeqParamSet.__Instance;
            fixed (int* __deltaPicOrderCnt4 = &deltaPicOrderCnt)
            {
                var __arg4 = __deltaPicOrderCnt4;
                var __ret = __Internal.H264bsdCheckDeltaPicOrderCnt(__arg0, __arg1, nalUnitType, picOrderPresentFlag, __arg4);
                return __ret;
            }
        }

        public static uint H264bsdCheckRedundantPicCnt(global::h264bsd.StrmDataT pStrmData, global::h264bsd.SeqParamSetT pSeqParamSet, global::h264bsd.PicParamSetT pPicParamSet, global::h264bsd.NalUnitTypeE nalUnitType, ref uint redundantPicCnt)
        {
            var __arg0 = ReferenceEquals(pStrmData, null) ? global::System.IntPtr.Zero : pStrmData.__Instance;
            var __arg1 = ReferenceEquals(pSeqParamSet, null) ? global::System.IntPtr.Zero : pSeqParamSet.__Instance;
            var __arg2 = ReferenceEquals(pPicParamSet, null) ? global::System.IntPtr.Zero : pPicParamSet.__Instance;
            fixed (uint* __redundantPicCnt4 = &redundantPicCnt)
            {
                var __arg4 = __redundantPicCnt4;
                var __ret = __Internal.H264bsdCheckRedundantPicCnt(__arg0, __arg1, __arg2, nalUnitType, __arg4);
                return __ret;
            }
        }

        public static uint H264bsdCheckPriorPicsFlag(ref uint noOutputOfPriorPicsFlag, global::h264bsd.StrmDataT pStrmData, global::h264bsd.SeqParamSetT pSeqParamSet, global::h264bsd.PicParamSetT pPicParamSet, global::h264bsd.NalUnitTypeE nalUnitType)
        {
            fixed (uint* __noOutputOfPriorPicsFlag0 = &noOutputOfPriorPicsFlag)
            {
                var __arg0 = __noOutputOfPriorPicsFlag0;
                var __arg1 = ReferenceEquals(pStrmData, null) ? global::System.IntPtr.Zero : pStrmData.__Instance;
                var __arg2 = ReferenceEquals(pSeqParamSet, null) ? global::System.IntPtr.Zero : pSeqParamSet.__Instance;
                var __arg3 = ReferenceEquals(pPicParamSet, null) ? global::System.IntPtr.Zero : pPicParamSet.__Instance;
                var __ret = __Internal.H264bsdCheckPriorPicsFlag(__arg0, __arg1, __arg2, __arg3, nalUnitType);
                return __ret;
            }
        }
    }

    public enum MbTypeE
    {
        P_Skip = 0,
        P_L0_16x16 = 1,
        P_L0L0_16x8 = 2,
        P_L0L0_8x16 = 3,
        P_8x8 = 4,
        P_8x8ref0 = 5,
        I_4x4 = 6,
        I_16x16_0_0_0 = 7,
        I_16x16_1_0_0 = 8,
        I_16x16_2_0_0 = 9,
        I_16x16_3_0_0 = 10,
        I_16x16_0_1_0 = 11,
        I_16x16_1_1_0 = 12,
        I_16x16_2_1_0 = 13,
        I_16x16_3_1_0 = 14,
        I_16x16_0_2_0 = 15,
        I_16x16_1_2_0 = 16,
        I_16x16_2_2_0 = 17,
        I_16x16_3_2_0 = 18,
        I_16x16_0_0_1 = 19,
        I_16x16_1_0_1 = 20,
        I_16x16_2_0_1 = 21,
        I_16x16_3_0_1 = 22,
        I_16x16_0_1_1 = 23,
        I_16x16_1_1_1 = 24,
        I_16x16_2_1_1 = 25,
        I_16x16_3_1_1 = 26,
        I_16x16_0_2_1 = 27,
        I_16x16_1_2_1 = 28,
        I_16x16_2_2_1 = 29,
        I_16x16_3_2_1 = 30,
        I_PCM = 31
    }

    public enum SubMbTypeE
    {
        P_L0_8x8 = 0,
        P_L0_8x4 = 1,
        P_L0_4x8 = 2,
        P_L0_4x4 = 3
    }

    public enum MbPartModeE
    {
        MB_P_16x16 = 0,
        MB_P_16x8 = 1,
        MB_P_8x16 = 2,
        MB_P_8x8 = 3
    }

    public enum SubMbPartModeE
    {
        MB_SP_8x8 = 0,
        MB_SP_8x4 = 1,
        MB_SP_4x8 = 2,
        MB_SP_4x4 = 3
    }

    public enum MbPartPredModeE
    {
        PRED_MODE_INTRA4x4 = 0,
        PRED_MODE_INTRA16x16 = 1,
        PRED_MODE_INTER = 2
    }

    public unsafe partial class MvT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal short hor;

            [FieldOffset(2)]
            internal short ver;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0mv_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.MvT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.MvT>();

        protected bool __ownsNativeInstance;

        internal static global::h264bsd.MvT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::h264bsd.MvT(native.ToPointer(), skipVTables);
        }

        internal static global::h264bsd.MvT __CreateInstance(global::h264bsd.MvT.__Internal native, bool skipVTables = false)
        {
            return new global::h264bsd.MvT(native, skipVTables);
        }

        private static void* __CopyValue(global::h264bsd.MvT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::h264bsd.MvT.__Internal));
            *(global::h264bsd.MvT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MvT(global::h264bsd.MvT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MvT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MvT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.MvT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MvT(global::h264bsd.MvT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.MvT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::h264bsd.MvT.__Internal*) __Instance) = *((global::h264bsd.MvT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::h264bsd.MvT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public short Hor
        {
            get
            {
                return ((global::h264bsd.MvT.__Internal*) __Instance)->hor;
            }

            set
            {
                ((global::h264bsd.MvT.__Internal*)__Instance)->hor = value;
            }
        }

        public short Ver
        {
            get
            {
                return ((global::h264bsd.MvT.__Internal*) __Instance)->ver;
            }

            set
            {
                ((global::h264bsd.MvT.__Internal*)__Instance)->ver = value;
            }
        }
    }

    public unsafe partial class MbPredT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 164)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal fixed uint prevIntra4x4PredModeFlag[16];

            [FieldOffset(64)]
            internal fixed uint remIntra4x4PredMode[16];

            [FieldOffset(128)]
            internal uint intraChromaPredMode;

            [FieldOffset(132)]
            internal fixed uint refIdxL0[4];

            [FieldOffset(148)]
            internal fixed byte mvdL0[16];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0mbPred_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.MbPredT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.MbPredT>();

        protected bool __ownsNativeInstance;

        internal static global::h264bsd.MbPredT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::h264bsd.MbPredT(native.ToPointer(), skipVTables);
        }

        internal static global::h264bsd.MbPredT __CreateInstance(global::h264bsd.MbPredT.__Internal native, bool skipVTables = false)
        {
            return new global::h264bsd.MbPredT(native, skipVTables);
        }

        private static void* __CopyValue(global::h264bsd.MbPredT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::h264bsd.MbPredT.__Internal));
            *(global::h264bsd.MbPredT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MbPredT(global::h264bsd.MbPredT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MbPredT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MbPredT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.MbPredT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MbPredT(global::h264bsd.MbPredT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.MbPredT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::h264bsd.MbPredT.__Internal*) __Instance) = *((global::h264bsd.MbPredT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::h264bsd.MbPredT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint[] PrevIntra4x4PredModeFlag
        {
            get
            {
                uint[] __value = null;
                if (((global::h264bsd.MbPredT.__Internal*) __Instance)->prevIntra4x4PredModeFlag != null)
                {
                    __value = new uint[16];
                    for (int i = 0; i < 16; i++)
                        __value[i] = ((global::h264bsd.MbPredT.__Internal*) __Instance)->prevIntra4x4PredModeFlag[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((global::h264bsd.MbPredT.__Internal*)__Instance)->prevIntra4x4PredModeFlag[i] = value[i];
                }
            }
        }

        public uint[] RemIntra4x4PredMode
        {
            get
            {
                uint[] __value = null;
                if (((global::h264bsd.MbPredT.__Internal*) __Instance)->remIntra4x4PredMode != null)
                {
                    __value = new uint[16];
                    for (int i = 0; i < 16; i++)
                        __value[i] = ((global::h264bsd.MbPredT.__Internal*) __Instance)->remIntra4x4PredMode[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((global::h264bsd.MbPredT.__Internal*)__Instance)->remIntra4x4PredMode[i] = value[i];
                }
            }
        }

        public uint IntraChromaPredMode
        {
            get
            {
                return ((global::h264bsd.MbPredT.__Internal*) __Instance)->intraChromaPredMode;
            }

            set
            {
                ((global::h264bsd.MbPredT.__Internal*)__Instance)->intraChromaPredMode = value;
            }
        }

        public uint[] RefIdxL0
        {
            get
            {
                uint[] __value = null;
                if (((global::h264bsd.MbPredT.__Internal*) __Instance)->refIdxL0 != null)
                {
                    __value = new uint[4];
                    for (int i = 0; i < 4; i++)
                        __value[i] = ((global::h264bsd.MbPredT.__Internal*) __Instance)->refIdxL0[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((global::h264bsd.MbPredT.__Internal*)__Instance)->refIdxL0[i] = value[i];
                }
            }
        }

        public global::h264bsd.MvT[] MvdL0
        {
            get
            {
                global::h264bsd.MvT[] __value = null;
                if (((global::h264bsd.MbPredT.__Internal*) __Instance)->mvdL0 != null)
                {
                    __value = new global::h264bsd.MvT[4];
                    for (int i = 0; i < 4; i++)
                        __value[i] = global::h264bsd.MvT.__CreateInstance(*((global::h264bsd.MvT.__Internal*)&(((global::h264bsd.MbPredT.__Internal*) __Instance)->mvdL0[i * sizeof(global::h264bsd.MvT.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 4)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 4; i++)
                        *(global::h264bsd.MvT.__Internal*) &((global::h264bsd.MbPredT.__Internal*)__Instance)->mvdL0[i * sizeof(global::h264bsd.MvT.__Internal)] = *(global::h264bsd.MvT.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    public unsafe partial class SubMbPredT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal fixed int subMbType[4];

            [FieldOffset(16)]
            internal fixed uint refIdxL0[4];

            [FieldOffset(32)]
            internal fixed byte mvdL0[16];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0subMbPred_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.SubMbPredT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.SubMbPredT>();

        protected bool __ownsNativeInstance;

        internal static global::h264bsd.SubMbPredT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::h264bsd.SubMbPredT(native.ToPointer(), skipVTables);
        }

        internal static global::h264bsd.SubMbPredT __CreateInstance(global::h264bsd.SubMbPredT.__Internal native, bool skipVTables = false)
        {
            return new global::h264bsd.SubMbPredT(native, skipVTables);
        }

        private static void* __CopyValue(global::h264bsd.SubMbPredT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::h264bsd.SubMbPredT.__Internal));
            *(global::h264bsd.SubMbPredT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SubMbPredT(global::h264bsd.SubMbPredT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SubMbPredT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public SubMbPredT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.SubMbPredT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SubMbPredT(global::h264bsd.SubMbPredT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.SubMbPredT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::h264bsd.SubMbPredT.__Internal*) __Instance) = *((global::h264bsd.SubMbPredT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::h264bsd.SubMbPredT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint[] RefIdxL0
        {
            get
            {
                uint[] __value = null;
                if (((global::h264bsd.SubMbPredT.__Internal*) __Instance)->refIdxL0 != null)
                {
                    __value = new uint[4];
                    for (int i = 0; i < 4; i++)
                        __value[i] = ((global::h264bsd.SubMbPredT.__Internal*) __Instance)->refIdxL0[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((global::h264bsd.SubMbPredT.__Internal*)__Instance)->refIdxL0[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class ResidualT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1816)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal fixed short totalCoeff[27];

            [FieldOffset(56)]
            internal fixed int level[416];

            [FieldOffset(1720)]
            internal fixed uint coeffMap[24];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0residual_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.ResidualT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.ResidualT>();

        protected bool __ownsNativeInstance;

        internal static global::h264bsd.ResidualT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::h264bsd.ResidualT(native.ToPointer(), skipVTables);
        }

        internal static global::h264bsd.ResidualT __CreateInstance(global::h264bsd.ResidualT.__Internal native, bool skipVTables = false)
        {
            return new global::h264bsd.ResidualT(native, skipVTables);
        }

        private static void* __CopyValue(global::h264bsd.ResidualT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::h264bsd.ResidualT.__Internal));
            *(global::h264bsd.ResidualT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ResidualT(global::h264bsd.ResidualT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ResidualT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ResidualT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.ResidualT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ResidualT(global::h264bsd.ResidualT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.ResidualT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::h264bsd.ResidualT.__Internal*) __Instance) = *((global::h264bsd.ResidualT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::h264bsd.ResidualT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public short[] TotalCoeff
        {
            get
            {
                short[] __value = null;
                if (((global::h264bsd.ResidualT.__Internal*) __Instance)->totalCoeff != null)
                {
                    __value = new short[27];
                    for (int i = 0; i < 27; i++)
                        __value[i] = ((global::h264bsd.ResidualT.__Internal*) __Instance)->totalCoeff[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 27; i++)
                        ((global::h264bsd.ResidualT.__Internal*)__Instance)->totalCoeff[i] = value[i];
                }
            }
        }

        public uint[] CoeffMap
        {
            get
            {
                uint[] __value = null;
                if (((global::h264bsd.ResidualT.__Internal*) __Instance)->coeffMap != null)
                {
                    __value = new uint[24];
                    for (int i = 0; i < 24; i++)
                        __value[i] = ((global::h264bsd.ResidualT.__Internal*) __Instance)->coeffMap[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 24; i++)
                        ((global::h264bsd.ResidualT.__Internal*)__Instance)->coeffMap[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class MacroblockLayerT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 2088)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::h264bsd.MbTypeE mbType;

            [FieldOffset(4)]
            internal uint codedBlockPattern;

            [FieldOffset(8)]
            internal int mbQpDelta;

            [FieldOffset(12)]
            internal global::h264bsd.MbPredT.__Internal mbPred;

            [FieldOffset(176)]
            internal global::h264bsd.SubMbPredT.__Internal subMbPred;

            [FieldOffset(272)]
            internal global::h264bsd.ResidualT.__Internal residual;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0macroblockLayer_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.MacroblockLayerT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.MacroblockLayerT>();

        protected bool __ownsNativeInstance;

        internal static global::h264bsd.MacroblockLayerT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::h264bsd.MacroblockLayerT(native.ToPointer(), skipVTables);
        }

        internal static global::h264bsd.MacroblockLayerT __CreateInstance(global::h264bsd.MacroblockLayerT.__Internal native, bool skipVTables = false)
        {
            return new global::h264bsd.MacroblockLayerT(native, skipVTables);
        }

        private static void* __CopyValue(global::h264bsd.MacroblockLayerT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::h264bsd.MacroblockLayerT.__Internal));
            *(global::h264bsd.MacroblockLayerT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MacroblockLayerT(global::h264bsd.MacroblockLayerT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MacroblockLayerT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MacroblockLayerT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.MacroblockLayerT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MacroblockLayerT(global::h264bsd.MacroblockLayerT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.MacroblockLayerT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::h264bsd.MacroblockLayerT.__Internal*) __Instance) = *((global::h264bsd.MacroblockLayerT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::h264bsd.MacroblockLayerT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::h264bsd.MbTypeE MbType
        {
            get
            {
                return ((global::h264bsd.MacroblockLayerT.__Internal*) __Instance)->mbType;
            }

            set
            {
                ((global::h264bsd.MacroblockLayerT.__Internal*)__Instance)->mbType = value;
            }
        }

        public uint CodedBlockPattern
        {
            get
            {
                return ((global::h264bsd.MacroblockLayerT.__Internal*) __Instance)->codedBlockPattern;
            }

            set
            {
                ((global::h264bsd.MacroblockLayerT.__Internal*)__Instance)->codedBlockPattern = value;
            }
        }

        public int MbQpDelta
        {
            get
            {
                return ((global::h264bsd.MacroblockLayerT.__Internal*) __Instance)->mbQpDelta;
            }

            set
            {
                ((global::h264bsd.MacroblockLayerT.__Internal*)__Instance)->mbQpDelta = value;
            }
        }

        public global::h264bsd.MbPredT MbPred
        {
            get
            {
                return global::h264bsd.MbPredT.__CreateInstance(new global::System.IntPtr(&((global::h264bsd.MacroblockLayerT.__Internal*) __Instance)->mbPred));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::h264bsd.MacroblockLayerT.__Internal*)__Instance)->mbPred = *(global::h264bsd.MbPredT.__Internal*) value.__Instance;
            }
        }

        public global::h264bsd.SubMbPredT SubMbPred
        {
            get
            {
                return global::h264bsd.SubMbPredT.__CreateInstance(new global::System.IntPtr(&((global::h264bsd.MacroblockLayerT.__Internal*) __Instance)->subMbPred));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::h264bsd.MacroblockLayerT.__Internal*)__Instance)->subMbPred = *(global::h264bsd.SubMbPredT.__Internal*) value.__Instance;
            }
        }

        public global::h264bsd.ResidualT Residual
        {
            get
            {
                return global::h264bsd.ResidualT.__CreateInstance(new global::System.IntPtr(&((global::h264bsd.MacroblockLayerT.__Internal*) __Instance)->residual));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::h264bsd.MacroblockLayerT.__Internal*)__Instance)->residual = *(global::h264bsd.ResidualT.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class MbStorage : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 256)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::h264bsd.MbTypeE mbType;

            [FieldOffset(4)]
            internal uint sliceId;

            [FieldOffset(8)]
            internal uint disableDeblockingFilterIdc;

            [FieldOffset(12)]
            internal int filterOffsetA;

            [FieldOffset(16)]
            internal int filterOffsetB;

            [FieldOffset(20)]
            internal uint qpY;

            [FieldOffset(24)]
            internal int chromaQpIndexOffset;

            [FieldOffset(28)]
            internal fixed short totalCoeff[27];

            [FieldOffset(82)]
            internal fixed byte intra4x4PredMode[16];

            [FieldOffset(100)]
            internal fixed uint refPic[4];

            [FieldOffset(120)]
            internal global::System.IntPtr refAddr;

            [FieldOffset(152)]
            internal fixed byte mv[64];

            [FieldOffset(216)]
            internal uint decoded;

            [FieldOffset(224)]
            internal global::System.IntPtr mbA;

            [FieldOffset(232)]
            internal global::System.IntPtr mbB;

            [FieldOffset(240)]
            internal global::System.IntPtr mbC;

            [FieldOffset(248)]
            internal global::System.IntPtr mbD;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0mbStorage@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.MbStorage> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.MbStorage>();

        protected bool __ownsNativeInstance;

        internal static global::h264bsd.MbStorage __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::h264bsd.MbStorage(native.ToPointer(), skipVTables);
        }

        internal static global::h264bsd.MbStorage __CreateInstance(global::h264bsd.MbStorage.__Internal native, bool skipVTables = false)
        {
            return new global::h264bsd.MbStorage(native, skipVTables);
        }

        private static void* __CopyValue(global::h264bsd.MbStorage.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::h264bsd.MbStorage.__Internal));
            *(global::h264bsd.MbStorage.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MbStorage(global::h264bsd.MbStorage.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MbStorage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public MbStorage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.MbStorage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MbStorage(global::h264bsd.MbStorage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.MbStorage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::h264bsd.MbStorage.__Internal*) __Instance) = *((global::h264bsd.MbStorage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::h264bsd.MbStorage __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::h264bsd.MbTypeE MbType
        {
            get
            {
                return ((global::h264bsd.MbStorage.__Internal*) __Instance)->mbType;
            }

            set
            {
                ((global::h264bsd.MbStorage.__Internal*)__Instance)->mbType = value;
            }
        }

        public uint SliceId
        {
            get
            {
                return ((global::h264bsd.MbStorage.__Internal*) __Instance)->sliceId;
            }

            set
            {
                ((global::h264bsd.MbStorage.__Internal*)__Instance)->sliceId = value;
            }
        }

        public uint DisableDeblockingFilterIdc
        {
            get
            {
                return ((global::h264bsd.MbStorage.__Internal*) __Instance)->disableDeblockingFilterIdc;
            }

            set
            {
                ((global::h264bsd.MbStorage.__Internal*)__Instance)->disableDeblockingFilterIdc = value;
            }
        }

        public int FilterOffsetA
        {
            get
            {
                return ((global::h264bsd.MbStorage.__Internal*) __Instance)->filterOffsetA;
            }

            set
            {
                ((global::h264bsd.MbStorage.__Internal*)__Instance)->filterOffsetA = value;
            }
        }

        public int FilterOffsetB
        {
            get
            {
                return ((global::h264bsd.MbStorage.__Internal*) __Instance)->filterOffsetB;
            }

            set
            {
                ((global::h264bsd.MbStorage.__Internal*)__Instance)->filterOffsetB = value;
            }
        }

        public uint QpY
        {
            get
            {
                return ((global::h264bsd.MbStorage.__Internal*) __Instance)->qpY;
            }

            set
            {
                ((global::h264bsd.MbStorage.__Internal*)__Instance)->qpY = value;
            }
        }

        public int ChromaQpIndexOffset
        {
            get
            {
                return ((global::h264bsd.MbStorage.__Internal*) __Instance)->chromaQpIndexOffset;
            }

            set
            {
                ((global::h264bsd.MbStorage.__Internal*)__Instance)->chromaQpIndexOffset = value;
            }
        }

        public short[] TotalCoeff
        {
            get
            {
                short[] __value = null;
                if (((global::h264bsd.MbStorage.__Internal*) __Instance)->totalCoeff != null)
                {
                    __value = new short[27];
                    for (int i = 0; i < 27; i++)
                        __value[i] = ((global::h264bsd.MbStorage.__Internal*) __Instance)->totalCoeff[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 27; i++)
                        ((global::h264bsd.MbStorage.__Internal*)__Instance)->totalCoeff[i] = value[i];
                }
            }
        }

        public byte[] Intra4x4PredMode
        {
            get
            {
                byte[] __value = null;
                if (((global::h264bsd.MbStorage.__Internal*) __Instance)->intra4x4PredMode != null)
                {
                    __value = new byte[16];
                    for (int i = 0; i < 16; i++)
                        __value[i] = ((global::h264bsd.MbStorage.__Internal*) __Instance)->intra4x4PredMode[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((global::h264bsd.MbStorage.__Internal*)__Instance)->intra4x4PredMode[i] = value[i];
                }
            }
        }

        public uint[] RefPic
        {
            get
            {
                uint[] __value = null;
                if (((global::h264bsd.MbStorage.__Internal*) __Instance)->refPic != null)
                {
                    __value = new uint[4];
                    for (int i = 0; i < 4; i++)
                        __value[i] = ((global::h264bsd.MbStorage.__Internal*) __Instance)->refPic[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((global::h264bsd.MbStorage.__Internal*)__Instance)->refPic[i] = value[i];
                }
            }
        }

        private byte*[] __refAddr;

        private bool __refAddrInitialised;
        public byte*[] RefAddr
        {
            get
            {
                if (!__refAddrInitialised)
                {
                    __refAddr = null;
                    __refAddrInitialised = true;
                }
                return __refAddr;
            }

            set
            {
                __refAddr = value;
                if (!__refAddrInitialised)
                {
                    __refAddrInitialised = true;
                }
            }
        }

        public global::h264bsd.MvT[] Mv
        {
            get
            {
                global::h264bsd.MvT[] __value = null;
                if (((global::h264bsd.MbStorage.__Internal*) __Instance)->mv != null)
                {
                    __value = new global::h264bsd.MvT[16];
                    for (int i = 0; i < 16; i++)
                        __value[i] = global::h264bsd.MvT.__CreateInstance(*((global::h264bsd.MvT.__Internal*)&(((global::h264bsd.MbStorage.__Internal*) __Instance)->mv[i * sizeof(global::h264bsd.MvT.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 16)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 16; i++)
                        *(global::h264bsd.MvT.__Internal*) &((global::h264bsd.MbStorage.__Internal*)__Instance)->mv[i * sizeof(global::h264bsd.MvT.__Internal)] = *(global::h264bsd.MvT.__Internal*)value[i].__Instance;
                }
            }
        }

        public uint Decoded
        {
            get
            {
                return ((global::h264bsd.MbStorage.__Internal*) __Instance)->decoded;
            }

            set
            {
                ((global::h264bsd.MbStorage.__Internal*)__Instance)->decoded = value;
            }
        }

        public global::h264bsd.MbStorage MbA
        {
            get
            {
                global::h264bsd.MbStorage __result0;
                if (((global::h264bsd.MbStorage.__Internal*) __Instance)->mbA == IntPtr.Zero) __result0 = null;
                else if (global::h264bsd.MbStorage.NativeToManagedMap.ContainsKey(((global::h264bsd.MbStorage.__Internal*) __Instance)->mbA))
                    __result0 = (global::h264bsd.MbStorage) global::h264bsd.MbStorage.NativeToManagedMap[((global::h264bsd.MbStorage.__Internal*) __Instance)->mbA];
                else __result0 = global::h264bsd.MbStorage.__CreateInstance(((global::h264bsd.MbStorage.__Internal*) __Instance)->mbA);
                return __result0;
            }

            set
            {
                ((global::h264bsd.MbStorage.__Internal*)__Instance)->mbA = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::h264bsd.MbStorage MbB
        {
            get
            {
                global::h264bsd.MbStorage __result0;
                if (((global::h264bsd.MbStorage.__Internal*) __Instance)->mbB == IntPtr.Zero) __result0 = null;
                else if (global::h264bsd.MbStorage.NativeToManagedMap.ContainsKey(((global::h264bsd.MbStorage.__Internal*) __Instance)->mbB))
                    __result0 = (global::h264bsd.MbStorage) global::h264bsd.MbStorage.NativeToManagedMap[((global::h264bsd.MbStorage.__Internal*) __Instance)->mbB];
                else __result0 = global::h264bsd.MbStorage.__CreateInstance(((global::h264bsd.MbStorage.__Internal*) __Instance)->mbB);
                return __result0;
            }

            set
            {
                ((global::h264bsd.MbStorage.__Internal*)__Instance)->mbB = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::h264bsd.MbStorage MbC
        {
            get
            {
                global::h264bsd.MbStorage __result0;
                if (((global::h264bsd.MbStorage.__Internal*) __Instance)->mbC == IntPtr.Zero) __result0 = null;
                else if (global::h264bsd.MbStorage.NativeToManagedMap.ContainsKey(((global::h264bsd.MbStorage.__Internal*) __Instance)->mbC))
                    __result0 = (global::h264bsd.MbStorage) global::h264bsd.MbStorage.NativeToManagedMap[((global::h264bsd.MbStorage.__Internal*) __Instance)->mbC];
                else __result0 = global::h264bsd.MbStorage.__CreateInstance(((global::h264bsd.MbStorage.__Internal*) __Instance)->mbC);
                return __result0;
            }

            set
            {
                ((global::h264bsd.MbStorage.__Internal*)__Instance)->mbC = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::h264bsd.MbStorage MbD
        {
            get
            {
                global::h264bsd.MbStorage __result0;
                if (((global::h264bsd.MbStorage.__Internal*) __Instance)->mbD == IntPtr.Zero) __result0 = null;
                else if (global::h264bsd.MbStorage.NativeToManagedMap.ContainsKey(((global::h264bsd.MbStorage.__Internal*) __Instance)->mbD))
                    __result0 = (global::h264bsd.MbStorage) global::h264bsd.MbStorage.NativeToManagedMap[((global::h264bsd.MbStorage.__Internal*) __Instance)->mbD];
                else __result0 = global::h264bsd.MbStorage.__CreateInstance(((global::h264bsd.MbStorage.__Internal*) __Instance)->mbD);
                return __result0;
            }

            set
            {
                ((global::h264bsd.MbStorage.__Internal*)__Instance)->mbD = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class h264bsd_macroblock_layer
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdDecodeMacroblockLayer@@YAIPEAUstrmData_t@@PEAUmacroblockLayer_t@@PEAUmbStorage@@II@Z")]
            internal static extern uint H264bsdDecodeMacroblockLayer(global::System.IntPtr pStrmData, global::System.IntPtr pMbLayer, global::System.IntPtr pMb, uint sliceType, uint numRefIdxActive);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdNumMbPart@@YAIW4mbType_e@@@Z")]
            internal static extern uint H264bsdNumMbPart(global::h264bsd.MbTypeE mbType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdNumSubMbPart@@YAIW4subMbType_e@@@Z")]
            internal static extern uint H264bsdNumSubMbPart(global::h264bsd.SubMbTypeE subMbType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdSubMbPartMode@@YA?AW4subMbPartMode_e@@W4subMbType_e@@@Z")]
            internal static extern global::h264bsd.SubMbPartModeE H264bsdSubMbPartMode(global::h264bsd.SubMbTypeE subMbType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdDecodeMacroblock@@YAIPEAUmbStorage@@PEAUmacroblockLayer_t@@PEAUimage_t@@PEAUdpbStorage_t@@PEAHIIPEAE@Z")]
            internal static extern uint H264bsdDecodeMacroblock(global::System.IntPtr pMb, global::System.IntPtr pMbLayer, global::System.IntPtr currImage, global::System.IntPtr dpb, int* qpY, uint mbNum, uint constrainedIntraPredFlag, byte* data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdPredModeIntra16x16@@YAIW4mbType_e@@@Z")]
            internal static extern uint H264bsdPredModeIntra16x16(global::h264bsd.MbTypeE mbType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdMbPartPredMode@@YA?AW4mbPartPredMode_e@@W4mbType_e@@@Z")]
            internal static extern global::h264bsd.MbPartPredModeE H264bsdMbPartPredMode(global::h264bsd.MbTypeE mbType);
        }

        public static uint H264bsdDecodeMacroblockLayer(global::h264bsd.StrmDataT pStrmData, global::h264bsd.MacroblockLayerT pMbLayer, global::h264bsd.MbStorage pMb, uint sliceType, uint numRefIdxActive)
        {
            var __arg0 = ReferenceEquals(pStrmData, null) ? global::System.IntPtr.Zero : pStrmData.__Instance;
            var __arg1 = ReferenceEquals(pMbLayer, null) ? global::System.IntPtr.Zero : pMbLayer.__Instance;
            var __arg2 = ReferenceEquals(pMb, null) ? global::System.IntPtr.Zero : pMb.__Instance;
            var __ret = __Internal.H264bsdDecodeMacroblockLayer(__arg0, __arg1, __arg2, sliceType, numRefIdxActive);
            return __ret;
        }

        public static uint H264bsdNumMbPart(global::h264bsd.MbTypeE mbType)
        {
            var __ret = __Internal.H264bsdNumMbPart(mbType);
            return __ret;
        }

        public static uint H264bsdNumSubMbPart(global::h264bsd.SubMbTypeE subMbType)
        {
            var __ret = __Internal.H264bsdNumSubMbPart(subMbType);
            return __ret;
        }

        public static global::h264bsd.SubMbPartModeE H264bsdSubMbPartMode(global::h264bsd.SubMbTypeE subMbType)
        {
            var __ret = __Internal.H264bsdSubMbPartMode(subMbType);
            return __ret;
        }

        public static uint H264bsdDecodeMacroblock(global::h264bsd.MbStorage pMb, global::h264bsd.MacroblockLayerT pMbLayer, global::h264bsd.ImageT currImage, global::h264bsd.DpbStorageT dpb, ref int qpY, uint mbNum, uint constrainedIntraPredFlag, byte* data)
        {
            var __arg0 = ReferenceEquals(pMb, null) ? global::System.IntPtr.Zero : pMb.__Instance;
            var __arg1 = ReferenceEquals(pMbLayer, null) ? global::System.IntPtr.Zero : pMbLayer.__Instance;
            var __arg2 = ReferenceEquals(currImage, null) ? global::System.IntPtr.Zero : currImage.__Instance;
            var __arg3 = ReferenceEquals(dpb, null) ? global::System.IntPtr.Zero : dpb.__Instance;
            fixed (int* __qpY4 = &qpY)
            {
                var __arg4 = __qpY4;
                var __ret = __Internal.H264bsdDecodeMacroblock(__arg0, __arg1, __arg2, __arg3, __arg4, mbNum, constrainedIntraPredFlag, data);
                return __ret;
            }
        }

        public static uint H264bsdPredModeIntra16x16(global::h264bsd.MbTypeE mbType)
        {
            var __ret = __Internal.H264bsdPredModeIntra16x16(mbType);
            return __ret;
        }

        public static global::h264bsd.MbPartPredModeE H264bsdMbPartPredMode(global::h264bsd.MbTypeE mbType)
        {
            var __ret = __Internal.H264bsdMbPartPredMode(mbType);
            return __ret;
        }
    }

    public unsafe partial class SliceStorageT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint sliceId;

            [FieldOffset(4)]
            internal uint numDecodedMbs;

            [FieldOffset(8)]
            internal uint lastMbAddr;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0sliceStorage_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.SliceStorageT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.SliceStorageT>();

        protected bool __ownsNativeInstance;

        internal static global::h264bsd.SliceStorageT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::h264bsd.SliceStorageT(native.ToPointer(), skipVTables);
        }

        internal static global::h264bsd.SliceStorageT __CreateInstance(global::h264bsd.SliceStorageT.__Internal native, bool skipVTables = false)
        {
            return new global::h264bsd.SliceStorageT(native, skipVTables);
        }

        private static void* __CopyValue(global::h264bsd.SliceStorageT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::h264bsd.SliceStorageT.__Internal));
            *(global::h264bsd.SliceStorageT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SliceStorageT(global::h264bsd.SliceStorageT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SliceStorageT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public SliceStorageT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.SliceStorageT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SliceStorageT(global::h264bsd.SliceStorageT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.SliceStorageT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::h264bsd.SliceStorageT.__Internal*) __Instance) = *((global::h264bsd.SliceStorageT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::h264bsd.SliceStorageT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint SliceId
        {
            get
            {
                return ((global::h264bsd.SliceStorageT.__Internal*) __Instance)->sliceId;
            }

            set
            {
                ((global::h264bsd.SliceStorageT.__Internal*)__Instance)->sliceId = value;
            }
        }

        public uint NumDecodedMbs
        {
            get
            {
                return ((global::h264bsd.SliceStorageT.__Internal*) __Instance)->numDecodedMbs;
            }

            set
            {
                ((global::h264bsd.SliceStorageT.__Internal*)__Instance)->numDecodedMbs = value;
            }
        }

        public uint LastMbAddr
        {
            get
            {
                return ((global::h264bsd.SliceStorageT.__Internal*) __Instance)->lastMbAddr;
            }

            set
            {
                ((global::h264bsd.SliceStorageT.__Internal*)__Instance)->lastMbAddr = value;
            }
        }
    }

    public unsafe partial class AubCheckT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 36)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal fixed byte nuPrev[8];

            [FieldOffset(8)]
            internal uint prevFrameNum;

            [FieldOffset(12)]
            internal uint prevIdrPicId;

            [FieldOffset(16)]
            internal uint prevPicOrderCntLsb;

            [FieldOffset(20)]
            internal int prevDeltaPicOrderCntBottom;

            [FieldOffset(24)]
            internal fixed int prevDeltaPicOrderCnt[2];

            [FieldOffset(32)]
            internal uint firstCallFlag;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0aubCheck_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.AubCheckT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.AubCheckT>();

        protected bool __ownsNativeInstance;

        internal static global::h264bsd.AubCheckT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::h264bsd.AubCheckT(native.ToPointer(), skipVTables);
        }

        internal static global::h264bsd.AubCheckT __CreateInstance(global::h264bsd.AubCheckT.__Internal native, bool skipVTables = false)
        {
            return new global::h264bsd.AubCheckT(native, skipVTables);
        }

        private static void* __CopyValue(global::h264bsd.AubCheckT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::h264bsd.AubCheckT.__Internal));
            *(global::h264bsd.AubCheckT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private AubCheckT(global::h264bsd.AubCheckT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected AubCheckT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public AubCheckT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.AubCheckT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public AubCheckT(global::h264bsd.AubCheckT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.AubCheckT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::h264bsd.AubCheckT.__Internal*) __Instance) = *((global::h264bsd.AubCheckT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::h264bsd.AubCheckT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::h264bsd.NalUnitT[] NuPrev
        {
            get
            {
                global::h264bsd.NalUnitT[] __value = null;
                if (((global::h264bsd.AubCheckT.__Internal*) __Instance)->nuPrev != null)
                {
                    __value = new global::h264bsd.NalUnitT[1];
                    for (int i = 0; i < 1; i++)
                        __value[i] = global::h264bsd.NalUnitT.__CreateInstance(*((global::h264bsd.NalUnitT.__Internal*)&(((global::h264bsd.AubCheckT.__Internal*) __Instance)->nuPrev[i * sizeof(global::h264bsd.NalUnitT.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 1)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 1; i++)
                        *(global::h264bsd.NalUnitT.__Internal*) &((global::h264bsd.AubCheckT.__Internal*)__Instance)->nuPrev[i * sizeof(global::h264bsd.NalUnitT.__Internal)] = *(global::h264bsd.NalUnitT.__Internal*)value[i].__Instance;
                }
            }
        }

        public uint PrevFrameNum
        {
            get
            {
                return ((global::h264bsd.AubCheckT.__Internal*) __Instance)->prevFrameNum;
            }

            set
            {
                ((global::h264bsd.AubCheckT.__Internal*)__Instance)->prevFrameNum = value;
            }
        }

        public uint PrevIdrPicId
        {
            get
            {
                return ((global::h264bsd.AubCheckT.__Internal*) __Instance)->prevIdrPicId;
            }

            set
            {
                ((global::h264bsd.AubCheckT.__Internal*)__Instance)->prevIdrPicId = value;
            }
        }

        public uint PrevPicOrderCntLsb
        {
            get
            {
                return ((global::h264bsd.AubCheckT.__Internal*) __Instance)->prevPicOrderCntLsb;
            }

            set
            {
                ((global::h264bsd.AubCheckT.__Internal*)__Instance)->prevPicOrderCntLsb = value;
            }
        }

        public int PrevDeltaPicOrderCntBottom
        {
            get
            {
                return ((global::h264bsd.AubCheckT.__Internal*) __Instance)->prevDeltaPicOrderCntBottom;
            }

            set
            {
                ((global::h264bsd.AubCheckT.__Internal*)__Instance)->prevDeltaPicOrderCntBottom = value;
            }
        }

        public int[] PrevDeltaPicOrderCnt
        {
            get
            {
                int[] __value = null;
                if (((global::h264bsd.AubCheckT.__Internal*) __Instance)->prevDeltaPicOrderCnt != null)
                {
                    __value = new int[2];
                    for (int i = 0; i < 2; i++)
                        __value[i] = ((global::h264bsd.AubCheckT.__Internal*) __Instance)->prevDeltaPicOrderCnt[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((global::h264bsd.AubCheckT.__Internal*)__Instance)->prevDeltaPicOrderCnt[i] = value[i];
                }
            }
        }

        public uint FirstCallFlag
        {
            get
            {
                return ((global::h264bsd.AubCheckT.__Internal*) __Instance)->firstCallFlag;
            }

            set
            {
                ((global::h264bsd.AubCheckT.__Internal*)__Instance)->firstCallFlag = value;
            }
        }
    }

    public unsafe partial class Storage : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4648)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint oldSpsId;

            [FieldOffset(4)]
            internal uint activePpsId;

            [FieldOffset(8)]
            internal uint activeSpsId;

            [FieldOffset(16)]
            internal global::System.IntPtr activePps;

            [FieldOffset(24)]
            internal global::System.IntPtr activeSps;

            [FieldOffset(32)]
            internal fixed long sps[32];

            [FieldOffset(288)]
            internal fixed long pps[256];

            [FieldOffset(2336)]
            internal global::System.IntPtr sliceGroupMap;

            [FieldOffset(2344)]
            internal uint picSizeInMbs;

            [FieldOffset(2348)]
            internal uint skipRedundantSlices;

            [FieldOffset(2352)]
            internal uint picStarted;

            [FieldOffset(2356)]
            internal uint validSliceInAccessUnit;

            [FieldOffset(2360)]
            internal fixed byte slice[12];

            [FieldOffset(2372)]
            internal uint numConcealedMbs;

            [FieldOffset(2376)]
            internal uint currentPicId;

            [FieldOffset(2384)]
            internal global::System.IntPtr mb;

            [FieldOffset(2392)]
            internal uint noReordering;

            [FieldOffset(2400)]
            internal fixed byte dpb[80];

            [FieldOffset(2480)]
            internal fixed byte poc[16];

            [FieldOffset(2496)]
            internal fixed byte aub[36];

            [FieldOffset(2536)]
            internal fixed byte currImage[40];

            [FieldOffset(2576)]
            internal fixed byte prevNalUnit[8];

            [FieldOffset(2584)]
            internal fixed byte sliceHeader[1976];

            [FieldOffset(4560)]
            internal uint prevBufNotFinished;

            [FieldOffset(4568)]
            internal global::System.IntPtr prevBufPointer;

            [FieldOffset(4576)]
            internal uint prevBytesConsumed;

            [FieldOffset(4584)]
            internal fixed byte strm[32];

            [FieldOffset(4616)]
            internal global::System.IntPtr mbLayer;

            [FieldOffset(4624)]
            internal uint pendingActivation;

            [FieldOffset(4628)]
            internal uint intraConcealmentFlag;

            [FieldOffset(4632)]
            internal global::System.IntPtr conversionBuffer;

            [FieldOffset(4640)]
            internal ulong conversionBufferSize;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0storage@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.Storage> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.Storage>();

        protected bool __ownsNativeInstance;

        internal static global::h264bsd.Storage __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::h264bsd.Storage(native.ToPointer(), skipVTables);
        }

        internal static global::h264bsd.Storage __CreateInstance(global::h264bsd.Storage.__Internal native, bool skipVTables = false)
        {
            return new global::h264bsd.Storage(native, skipVTables);
        }

        private static void* __CopyValue(global::h264bsd.Storage.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::h264bsd.Storage.__Internal));
            *(global::h264bsd.Storage.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Storage(global::h264bsd.Storage.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Storage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Storage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.Storage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Storage(global::h264bsd.Storage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.Storage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::h264bsd.Storage.__Internal*) __Instance) = *((global::h264bsd.Storage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::h264bsd.Storage __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint OldSpsId
        {
            get
            {
                return ((global::h264bsd.Storage.__Internal*) __Instance)->oldSpsId;
            }

            set
            {
                ((global::h264bsd.Storage.__Internal*)__Instance)->oldSpsId = value;
            }
        }

        public uint ActivePpsId
        {
            get
            {
                return ((global::h264bsd.Storage.__Internal*) __Instance)->activePpsId;
            }

            set
            {
                ((global::h264bsd.Storage.__Internal*)__Instance)->activePpsId = value;
            }
        }

        public uint ActiveSpsId
        {
            get
            {
                return ((global::h264bsd.Storage.__Internal*) __Instance)->activeSpsId;
            }

            set
            {
                ((global::h264bsd.Storage.__Internal*)__Instance)->activeSpsId = value;
            }
        }

        public global::h264bsd.PicParamSetT ActivePps
        {
            get
            {
                global::h264bsd.PicParamSetT __result0;
                if (((global::h264bsd.Storage.__Internal*) __Instance)->activePps == IntPtr.Zero) __result0 = null;
                else if (global::h264bsd.PicParamSetT.NativeToManagedMap.ContainsKey(((global::h264bsd.Storage.__Internal*) __Instance)->activePps))
                    __result0 = (global::h264bsd.PicParamSetT) global::h264bsd.PicParamSetT.NativeToManagedMap[((global::h264bsd.Storage.__Internal*) __Instance)->activePps];
                else __result0 = global::h264bsd.PicParamSetT.__CreateInstance(((global::h264bsd.Storage.__Internal*) __Instance)->activePps);
                return __result0;
            }

            set
            {
                ((global::h264bsd.Storage.__Internal*)__Instance)->activePps = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::h264bsd.SeqParamSetT ActiveSps
        {
            get
            {
                global::h264bsd.SeqParamSetT __result0;
                if (((global::h264bsd.Storage.__Internal*) __Instance)->activeSps == IntPtr.Zero) __result0 = null;
                else if (global::h264bsd.SeqParamSetT.NativeToManagedMap.ContainsKey(((global::h264bsd.Storage.__Internal*) __Instance)->activeSps))
                    __result0 = (global::h264bsd.SeqParamSetT) global::h264bsd.SeqParamSetT.NativeToManagedMap[((global::h264bsd.Storage.__Internal*) __Instance)->activeSps];
                else __result0 = global::h264bsd.SeqParamSetT.__CreateInstance(((global::h264bsd.Storage.__Internal*) __Instance)->activeSps);
                return __result0;
            }

            set
            {
                ((global::h264bsd.Storage.__Internal*)__Instance)->activeSps = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::h264bsd.SeqParamSetT[] Sps
        {
            get
            {
                global::h264bsd.SeqParamSetT[] __value = null;
                if (((global::h264bsd.Storage.__Internal*) __Instance)->sps != null)
                {
                    __value = new global::h264bsd.SeqParamSetT[32];
                    for (int i = 0; i < 32; i++)
                        __value[i] = global::h264bsd.SeqParamSetT.__CreateInstance((global::System.IntPtr) ((global::h264bsd.Storage.__Internal*) __Instance)->sps[i]);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 32)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 32; i++)
                        ((global::h264bsd.Storage.__Internal*)__Instance)->sps[i] = (long) value[i].__Instance;
                }
            }
        }

        public global::h264bsd.PicParamSetT[] Pps
        {
            get
            {
                global::h264bsd.PicParamSetT[] __value = null;
                if (((global::h264bsd.Storage.__Internal*) __Instance)->pps != null)
                {
                    __value = new global::h264bsd.PicParamSetT[256];
                    for (int i = 0; i < 256; i++)
                        __value[i] = global::h264bsd.PicParamSetT.__CreateInstance((global::System.IntPtr) ((global::h264bsd.Storage.__Internal*) __Instance)->pps[i]);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 256)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 256; i++)
                        ((global::h264bsd.Storage.__Internal*)__Instance)->pps[i] = (long) value[i].__Instance;
                }
            }
        }

        public uint* SliceGroupMap
        {
            get
            {
                return (uint*) ((global::h264bsd.Storage.__Internal*) __Instance)->sliceGroupMap;
            }

            set
            {
                ((global::h264bsd.Storage.__Internal*)__Instance)->sliceGroupMap = (global::System.IntPtr) value;
            }
        }

        public uint PicSizeInMbs
        {
            get
            {
                return ((global::h264bsd.Storage.__Internal*) __Instance)->picSizeInMbs;
            }

            set
            {
                ((global::h264bsd.Storage.__Internal*)__Instance)->picSizeInMbs = value;
            }
        }

        public uint SkipRedundantSlices
        {
            get
            {
                return ((global::h264bsd.Storage.__Internal*) __Instance)->skipRedundantSlices;
            }

            set
            {
                ((global::h264bsd.Storage.__Internal*)__Instance)->skipRedundantSlices = value;
            }
        }

        public uint PicStarted
        {
            get
            {
                return ((global::h264bsd.Storage.__Internal*) __Instance)->picStarted;
            }

            set
            {
                ((global::h264bsd.Storage.__Internal*)__Instance)->picStarted = value;
            }
        }

        public uint ValidSliceInAccessUnit
        {
            get
            {
                return ((global::h264bsd.Storage.__Internal*) __Instance)->validSliceInAccessUnit;
            }

            set
            {
                ((global::h264bsd.Storage.__Internal*)__Instance)->validSliceInAccessUnit = value;
            }
        }

        public global::h264bsd.SliceStorageT[] Slice
        {
            get
            {
                global::h264bsd.SliceStorageT[] __value = null;
                if (((global::h264bsd.Storage.__Internal*) __Instance)->slice != null)
                {
                    __value = new global::h264bsd.SliceStorageT[1];
                    for (int i = 0; i < 1; i++)
                        __value[i] = global::h264bsd.SliceStorageT.__CreateInstance(*((global::h264bsd.SliceStorageT.__Internal*)&(((global::h264bsd.Storage.__Internal*) __Instance)->slice[i * sizeof(global::h264bsd.SliceStorageT.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 1)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 1; i++)
                        *(global::h264bsd.SliceStorageT.__Internal*) &((global::h264bsd.Storage.__Internal*)__Instance)->slice[i * sizeof(global::h264bsd.SliceStorageT.__Internal)] = *(global::h264bsd.SliceStorageT.__Internal*)value[i].__Instance;
                }
            }
        }

        public uint NumConcealedMbs
        {
            get
            {
                return ((global::h264bsd.Storage.__Internal*) __Instance)->numConcealedMbs;
            }

            set
            {
                ((global::h264bsd.Storage.__Internal*)__Instance)->numConcealedMbs = value;
            }
        }

        public uint CurrentPicId
        {
            get
            {
                return ((global::h264bsd.Storage.__Internal*) __Instance)->currentPicId;
            }

            set
            {
                ((global::h264bsd.Storage.__Internal*)__Instance)->currentPicId = value;
            }
        }

        public global::h264bsd.MbStorage Mb
        {
            get
            {
                global::h264bsd.MbStorage __result0;
                if (((global::h264bsd.Storage.__Internal*) __Instance)->mb == IntPtr.Zero) __result0 = null;
                else if (global::h264bsd.MbStorage.NativeToManagedMap.ContainsKey(((global::h264bsd.Storage.__Internal*) __Instance)->mb))
                    __result0 = (global::h264bsd.MbStorage) global::h264bsd.MbStorage.NativeToManagedMap[((global::h264bsd.Storage.__Internal*) __Instance)->mb];
                else __result0 = global::h264bsd.MbStorage.__CreateInstance(((global::h264bsd.Storage.__Internal*) __Instance)->mb);
                return __result0;
            }

            set
            {
                ((global::h264bsd.Storage.__Internal*)__Instance)->mb = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public uint NoReordering
        {
            get
            {
                return ((global::h264bsd.Storage.__Internal*) __Instance)->noReordering;
            }

            set
            {
                ((global::h264bsd.Storage.__Internal*)__Instance)->noReordering = value;
            }
        }

        public global::h264bsd.DpbStorageT[] Dpb
        {
            get
            {
                global::h264bsd.DpbStorageT[] __value = null;
                if (((global::h264bsd.Storage.__Internal*) __Instance)->dpb != null)
                {
                    __value = new global::h264bsd.DpbStorageT[1];
                    for (int i = 0; i < 1; i++)
                        __value[i] = global::h264bsd.DpbStorageT.__CreateInstance(*((global::h264bsd.DpbStorageT.__Internal*)&(((global::h264bsd.Storage.__Internal*) __Instance)->dpb[i * sizeof(global::h264bsd.DpbStorageT.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 1)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 1; i++)
                        *(global::h264bsd.DpbStorageT.__Internal*) &((global::h264bsd.Storage.__Internal*)__Instance)->dpb[i * sizeof(global::h264bsd.DpbStorageT.__Internal)] = *(global::h264bsd.DpbStorageT.__Internal*)value[i].__Instance;
                }
            }
        }

        public global::h264bsd.PocStorageT[] Poc
        {
            get
            {
                global::h264bsd.PocStorageT[] __value = null;
                if (((global::h264bsd.Storage.__Internal*) __Instance)->poc != null)
                {
                    __value = new global::h264bsd.PocStorageT[1];
                    for (int i = 0; i < 1; i++)
                        __value[i] = global::h264bsd.PocStorageT.__CreateInstance(*((global::h264bsd.PocStorageT.__Internal*)&(((global::h264bsd.Storage.__Internal*) __Instance)->poc[i * sizeof(global::h264bsd.PocStorageT.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 1)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 1; i++)
                        *(global::h264bsd.PocStorageT.__Internal*) &((global::h264bsd.Storage.__Internal*)__Instance)->poc[i * sizeof(global::h264bsd.PocStorageT.__Internal)] = *(global::h264bsd.PocStorageT.__Internal*)value[i].__Instance;
                }
            }
        }

        public global::h264bsd.AubCheckT[] Aub
        {
            get
            {
                global::h264bsd.AubCheckT[] __value = null;
                if (((global::h264bsd.Storage.__Internal*) __Instance)->aub != null)
                {
                    __value = new global::h264bsd.AubCheckT[1];
                    for (int i = 0; i < 1; i++)
                        __value[i] = global::h264bsd.AubCheckT.__CreateInstance(*((global::h264bsd.AubCheckT.__Internal*)&(((global::h264bsd.Storage.__Internal*) __Instance)->aub[i * sizeof(global::h264bsd.AubCheckT.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 1)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 1; i++)
                        *(global::h264bsd.AubCheckT.__Internal*) &((global::h264bsd.Storage.__Internal*)__Instance)->aub[i * sizeof(global::h264bsd.AubCheckT.__Internal)] = *(global::h264bsd.AubCheckT.__Internal*)value[i].__Instance;
                }
            }
        }

        public global::h264bsd.ImageT[] CurrImage
        {
            get
            {
                global::h264bsd.ImageT[] __value = null;
                if (((global::h264bsd.Storage.__Internal*) __Instance)->currImage != null)
                {
                    __value = new global::h264bsd.ImageT[1];
                    for (int i = 0; i < 1; i++)
                        __value[i] = global::h264bsd.ImageT.__CreateInstance(*((global::h264bsd.ImageT.__Internal*)&(((global::h264bsd.Storage.__Internal*) __Instance)->currImage[i * sizeof(global::h264bsd.ImageT.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 1)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 1; i++)
                        *(global::h264bsd.ImageT.__Internal*) &((global::h264bsd.Storage.__Internal*)__Instance)->currImage[i * sizeof(global::h264bsd.ImageT.__Internal)] = *(global::h264bsd.ImageT.__Internal*)value[i].__Instance;
                }
            }
        }

        public global::h264bsd.NalUnitT[] PrevNalUnit
        {
            get
            {
                global::h264bsd.NalUnitT[] __value = null;
                if (((global::h264bsd.Storage.__Internal*) __Instance)->prevNalUnit != null)
                {
                    __value = new global::h264bsd.NalUnitT[1];
                    for (int i = 0; i < 1; i++)
                        __value[i] = global::h264bsd.NalUnitT.__CreateInstance(*((global::h264bsd.NalUnitT.__Internal*)&(((global::h264bsd.Storage.__Internal*) __Instance)->prevNalUnit[i * sizeof(global::h264bsd.NalUnitT.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 1)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 1; i++)
                        *(global::h264bsd.NalUnitT.__Internal*) &((global::h264bsd.Storage.__Internal*)__Instance)->prevNalUnit[i * sizeof(global::h264bsd.NalUnitT.__Internal)] = *(global::h264bsd.NalUnitT.__Internal*)value[i].__Instance;
                }
            }
        }

        public global::h264bsd.SliceHeaderT[] SliceHeader
        {
            get
            {
                global::h264bsd.SliceHeaderT[] __value = null;
                if (((global::h264bsd.Storage.__Internal*) __Instance)->sliceHeader != null)
                {
                    __value = new global::h264bsd.SliceHeaderT[2];
                    for (int i = 0; i < 2; i++)
                        __value[i] = global::h264bsd.SliceHeaderT.__CreateInstance(*((global::h264bsd.SliceHeaderT.__Internal*)&(((global::h264bsd.Storage.__Internal*) __Instance)->sliceHeader[i * sizeof(global::h264bsd.SliceHeaderT.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 2)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 2; i++)
                        *(global::h264bsd.SliceHeaderT.__Internal*) &((global::h264bsd.Storage.__Internal*)__Instance)->sliceHeader[i * sizeof(global::h264bsd.SliceHeaderT.__Internal)] = *(global::h264bsd.SliceHeaderT.__Internal*)value[i].__Instance;
                }
            }
        }

        public uint PrevBufNotFinished
        {
            get
            {
                return ((global::h264bsd.Storage.__Internal*) __Instance)->prevBufNotFinished;
            }

            set
            {
                ((global::h264bsd.Storage.__Internal*)__Instance)->prevBufNotFinished = value;
            }
        }

        public byte* PrevBufPointer
        {
            get
            {
                return (byte*) ((global::h264bsd.Storage.__Internal*) __Instance)->prevBufPointer;
            }

            set
            {
                ((global::h264bsd.Storage.__Internal*)__Instance)->prevBufPointer = (global::System.IntPtr) value;
            }
        }

        public uint PrevBytesConsumed
        {
            get
            {
                return ((global::h264bsd.Storage.__Internal*) __Instance)->prevBytesConsumed;
            }

            set
            {
                ((global::h264bsd.Storage.__Internal*)__Instance)->prevBytesConsumed = value;
            }
        }

        public global::h264bsd.StrmDataT[] Strm
        {
            get
            {
                global::h264bsd.StrmDataT[] __value = null;
                if (((global::h264bsd.Storage.__Internal*) __Instance)->strm != null)
                {
                    __value = new global::h264bsd.StrmDataT[1];
                    for (int i = 0; i < 1; i++)
                        __value[i] = global::h264bsd.StrmDataT.__CreateInstance(*((global::h264bsd.StrmDataT.__Internal*)&(((global::h264bsd.Storage.__Internal*) __Instance)->strm[i * sizeof(global::h264bsd.StrmDataT.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 1)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 1; i++)
                        *(global::h264bsd.StrmDataT.__Internal*) &((global::h264bsd.Storage.__Internal*)__Instance)->strm[i * sizeof(global::h264bsd.StrmDataT.__Internal)] = *(global::h264bsd.StrmDataT.__Internal*)value[i].__Instance;
                }
            }
        }

        public global::h264bsd.MacroblockLayerT MbLayer
        {
            get
            {
                global::h264bsd.MacroblockLayerT __result0;
                if (((global::h264bsd.Storage.__Internal*) __Instance)->mbLayer == IntPtr.Zero) __result0 = null;
                else if (global::h264bsd.MacroblockLayerT.NativeToManagedMap.ContainsKey(((global::h264bsd.Storage.__Internal*) __Instance)->mbLayer))
                    __result0 = (global::h264bsd.MacroblockLayerT) global::h264bsd.MacroblockLayerT.NativeToManagedMap[((global::h264bsd.Storage.__Internal*) __Instance)->mbLayer];
                else __result0 = global::h264bsd.MacroblockLayerT.__CreateInstance(((global::h264bsd.Storage.__Internal*) __Instance)->mbLayer);
                return __result0;
            }

            set
            {
                ((global::h264bsd.Storage.__Internal*)__Instance)->mbLayer = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public uint PendingActivation
        {
            get
            {
                return ((global::h264bsd.Storage.__Internal*) __Instance)->pendingActivation;
            }

            set
            {
                ((global::h264bsd.Storage.__Internal*)__Instance)->pendingActivation = value;
            }
        }

        public uint IntraConcealmentFlag
        {
            get
            {
                return ((global::h264bsd.Storage.__Internal*) __Instance)->intraConcealmentFlag;
            }

            set
            {
                ((global::h264bsd.Storage.__Internal*)__Instance)->intraConcealmentFlag = value;
            }
        }

        public uint* ConversionBuffer
        {
            get
            {
                return (uint*) ((global::h264bsd.Storage.__Internal*) __Instance)->conversionBuffer;
            }

            set
            {
                ((global::h264bsd.Storage.__Internal*)__Instance)->conversionBuffer = (global::System.IntPtr) value;
            }
        }

        public ulong ConversionBufferSize
        {
            get
            {
                return ((global::h264bsd.Storage.__Internal*) __Instance)->conversionBufferSize;
            }

            set
            {
                ((global::h264bsd.Storage.__Internal*)__Instance)->conversionBufferSize = value;
            }
        }
    }

    public unsafe partial class h264bsd_storage
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdInitStorage@@YAXPEAUstorage@@@Z")]
            internal static extern void H264bsdInitStorage(global::System.IntPtr pStorage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdResetStorage@@YAXPEAUstorage@@@Z")]
            internal static extern void H264bsdResetStorage(global::System.IntPtr pStorage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdIsStartOfPicture@@YAIPEAUstorage@@@Z")]
            internal static extern uint H264bsdIsStartOfPicture(global::System.IntPtr pStorage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdIsEndOfPicture@@YAIPEAUstorage@@@Z")]
            internal static extern uint H264bsdIsEndOfPicture(global::System.IntPtr pStorage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdStoreSeqParamSet@@YAIPEAUstorage@@PEAUseqParamSet_t@@@Z")]
            internal static extern uint H264bsdStoreSeqParamSet(global::System.IntPtr pStorage, global::System.IntPtr pSeqParamSet);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdStorePicParamSet@@YAIPEAUstorage@@PEAUpicParamSet_t@@@Z")]
            internal static extern uint H264bsdStorePicParamSet(global::System.IntPtr pStorage, global::System.IntPtr pPicParamSet);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdActivateParamSets@@YAIPEAUstorage@@II@Z")]
            internal static extern uint H264bsdActivateParamSets(global::System.IntPtr pStorage, uint ppsId, uint isIdr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdComputeSliceGroupMap@@YAXPEAUstorage@@I@Z")]
            internal static extern void H264bsdComputeSliceGroupMap(global::System.IntPtr pStorage, uint sliceGroupChangeCycle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdCheckAccessUnitBoundary@@YAIPEAUstrmData_t@@PEAUnalUnit_t@@PEAUstorage@@PEAI@Z")]
            internal static extern uint H264bsdCheckAccessUnitBoundary(global::System.IntPtr strm, global::System.IntPtr nuNext, global::System.IntPtr storage, uint* accessUnitBoundaryFlag);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdValidParamSets@@YAIPEAUstorage@@@Z")]
            internal static extern uint H264bsdValidParamSets(global::System.IntPtr pStorage);
        }

        public static void H264bsdInitStorage(global::h264bsd.Storage pStorage)
        {
            var __arg0 = ReferenceEquals(pStorage, null) ? global::System.IntPtr.Zero : pStorage.__Instance;
            __Internal.H264bsdInitStorage(__arg0);
        }

        public static void H264bsdResetStorage(global::h264bsd.Storage pStorage)
        {
            var __arg0 = ReferenceEquals(pStorage, null) ? global::System.IntPtr.Zero : pStorage.__Instance;
            __Internal.H264bsdResetStorage(__arg0);
        }

        public static uint H264bsdIsStartOfPicture(global::h264bsd.Storage pStorage)
        {
            var __arg0 = ReferenceEquals(pStorage, null) ? global::System.IntPtr.Zero : pStorage.__Instance;
            var __ret = __Internal.H264bsdIsStartOfPicture(__arg0);
            return __ret;
        }

        public static uint H264bsdIsEndOfPicture(global::h264bsd.Storage pStorage)
        {
            var __arg0 = ReferenceEquals(pStorage, null) ? global::System.IntPtr.Zero : pStorage.__Instance;
            var __ret = __Internal.H264bsdIsEndOfPicture(__arg0);
            return __ret;
        }

        public static uint H264bsdStoreSeqParamSet(global::h264bsd.Storage pStorage, global::h264bsd.SeqParamSetT pSeqParamSet)
        {
            var __arg0 = ReferenceEquals(pStorage, null) ? global::System.IntPtr.Zero : pStorage.__Instance;
            var __arg1 = ReferenceEquals(pSeqParamSet, null) ? global::System.IntPtr.Zero : pSeqParamSet.__Instance;
            var __ret = __Internal.H264bsdStoreSeqParamSet(__arg0, __arg1);
            return __ret;
        }

        public static uint H264bsdStorePicParamSet(global::h264bsd.Storage pStorage, global::h264bsd.PicParamSetT pPicParamSet)
        {
            var __arg0 = ReferenceEquals(pStorage, null) ? global::System.IntPtr.Zero : pStorage.__Instance;
            var __arg1 = ReferenceEquals(pPicParamSet, null) ? global::System.IntPtr.Zero : pPicParamSet.__Instance;
            var __ret = __Internal.H264bsdStorePicParamSet(__arg0, __arg1);
            return __ret;
        }

        public static uint H264bsdActivateParamSets(global::h264bsd.Storage pStorage, uint ppsId, uint isIdr)
        {
            var __arg0 = ReferenceEquals(pStorage, null) ? global::System.IntPtr.Zero : pStorage.__Instance;
            var __ret = __Internal.H264bsdActivateParamSets(__arg0, ppsId, isIdr);
            return __ret;
        }

        public static void H264bsdComputeSliceGroupMap(global::h264bsd.Storage pStorage, uint sliceGroupChangeCycle)
        {
            var __arg0 = ReferenceEquals(pStorage, null) ? global::System.IntPtr.Zero : pStorage.__Instance;
            __Internal.H264bsdComputeSliceGroupMap(__arg0, sliceGroupChangeCycle);
        }

        public static uint H264bsdCheckAccessUnitBoundary(global::h264bsd.StrmDataT strm, global::h264bsd.NalUnitT nuNext, global::h264bsd.Storage storage, ref uint accessUnitBoundaryFlag)
        {
            var __arg0 = ReferenceEquals(strm, null) ? global::System.IntPtr.Zero : strm.__Instance;
            var __arg1 = ReferenceEquals(nuNext, null) ? global::System.IntPtr.Zero : nuNext.__Instance;
            var __arg2 = ReferenceEquals(storage, null) ? global::System.IntPtr.Zero : storage.__Instance;
            fixed (uint* __accessUnitBoundaryFlag3 = &accessUnitBoundaryFlag)
            {
                var __arg3 = __accessUnitBoundaryFlag3;
                var __ret = __Internal.H264bsdCheckAccessUnitBoundary(__arg0, __arg1, __arg2, __arg3);
                return __ret;
            }
        }

        public static uint H264bsdValidParamSets(global::h264bsd.Storage pStorage)
        {
            var __arg0 = ReferenceEquals(pStorage, null) ? global::System.IntPtr.Zero : pStorage.__Instance;
            var __ret = __Internal.H264bsdValidParamSets(__arg0);
            return __ret;
        }
    }

    public unsafe partial class StrmDataT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr pStrmBuffStart;

            [FieldOffset(8)]
            internal global::System.IntPtr pStrmCurrPos;

            [FieldOffset(16)]
            internal uint bitPosInWord;

            [FieldOffset(20)]
            internal uint strmBuffSize;

            [FieldOffset(24)]
            internal uint strmBuffReadBits;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0strmData_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.StrmDataT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.StrmDataT>();

        protected bool __ownsNativeInstance;

        internal static global::h264bsd.StrmDataT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::h264bsd.StrmDataT(native.ToPointer(), skipVTables);
        }

        internal static global::h264bsd.StrmDataT __CreateInstance(global::h264bsd.StrmDataT.__Internal native, bool skipVTables = false)
        {
            return new global::h264bsd.StrmDataT(native, skipVTables);
        }

        private static void* __CopyValue(global::h264bsd.StrmDataT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::h264bsd.StrmDataT.__Internal));
            *(global::h264bsd.StrmDataT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StrmDataT(global::h264bsd.StrmDataT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected StrmDataT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public StrmDataT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.StrmDataT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public StrmDataT(global::h264bsd.StrmDataT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.StrmDataT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::h264bsd.StrmDataT.__Internal*) __Instance) = *((global::h264bsd.StrmDataT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::h264bsd.StrmDataT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte* PStrmBuffStart
        {
            get
            {
                return (byte*) ((global::h264bsd.StrmDataT.__Internal*) __Instance)->pStrmBuffStart;
            }

            set
            {
                ((global::h264bsd.StrmDataT.__Internal*)__Instance)->pStrmBuffStart = (global::System.IntPtr) value;
            }
        }

        public byte* PStrmCurrPos
        {
            get
            {
                return (byte*) ((global::h264bsd.StrmDataT.__Internal*) __Instance)->pStrmCurrPos;
            }

            set
            {
                ((global::h264bsd.StrmDataT.__Internal*)__Instance)->pStrmCurrPos = (global::System.IntPtr) value;
            }
        }

        public uint BitPosInWord
        {
            get
            {
                return ((global::h264bsd.StrmDataT.__Internal*) __Instance)->bitPosInWord;
            }

            set
            {
                ((global::h264bsd.StrmDataT.__Internal*)__Instance)->bitPosInWord = value;
            }
        }

        public uint StrmBuffSize
        {
            get
            {
                return ((global::h264bsd.StrmDataT.__Internal*) __Instance)->strmBuffSize;
            }

            set
            {
                ((global::h264bsd.StrmDataT.__Internal*)__Instance)->strmBuffSize = value;
            }
        }

        public uint StrmBuffReadBits
        {
            get
            {
                return ((global::h264bsd.StrmDataT.__Internal*) __Instance)->strmBuffReadBits;
            }

            set
            {
                ((global::h264bsd.StrmDataT.__Internal*)__Instance)->strmBuffReadBits = value;
            }
        }
    }

    public unsafe partial class h264bsd_stream
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdGetBits@@YAIPEAUstrmData_t@@I@Z")]
            internal static extern uint H264bsdGetBits(global::System.IntPtr pStrmData, uint numBits);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdShowBits32@@YAIPEAUstrmData_t@@@Z")]
            internal static extern uint H264bsdShowBits32(global::System.IntPtr pStrmData);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdFlushBits@@YAIPEAUstrmData_t@@I@Z")]
            internal static extern uint H264bsdFlushBits(global::System.IntPtr pStrmData, uint numBits);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdIsByteAligned@@YAIPEAUstrmData_t@@@Z")]
            internal static extern uint H264bsdIsByteAligned(global::System.IntPtr _0);
        }

        public static uint H264bsdGetBits(global::h264bsd.StrmDataT pStrmData, uint numBits)
        {
            var __arg0 = ReferenceEquals(pStrmData, null) ? global::System.IntPtr.Zero : pStrmData.__Instance;
            var __ret = __Internal.H264bsdGetBits(__arg0, numBits);
            return __ret;
        }

        public static uint H264bsdShowBits32(global::h264bsd.StrmDataT pStrmData)
        {
            var __arg0 = ReferenceEquals(pStrmData, null) ? global::System.IntPtr.Zero : pStrmData.__Instance;
            var __ret = __Internal.H264bsdShowBits32(__arg0);
            return __ret;
        }

        public static uint H264bsdFlushBits(global::h264bsd.StrmDataT pStrmData, uint numBits)
        {
            var __arg0 = ReferenceEquals(pStrmData, null) ? global::System.IntPtr.Zero : pStrmData.__Instance;
            var __ret = __Internal.H264bsdFlushBits(__arg0, numBits);
            return __ret;
        }

        public static uint H264bsdIsByteAligned(global::h264bsd.StrmDataT _0)
        {
            var __arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
            var __ret = __Internal.H264bsdIsByteAligned(__arg0);
            return __ret;
        }
    }

    public unsafe partial class SeqParamSetT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 104)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint profileIdc;

            [FieldOffset(4)]
            internal uint levelIdc;

            [FieldOffset(8)]
            internal uint seqParameterSetId;

            [FieldOffset(12)]
            internal uint maxFrameNum;

            [FieldOffset(16)]
            internal uint picOrderCntType;

            [FieldOffset(20)]
            internal uint maxPicOrderCntLsb;

            [FieldOffset(24)]
            internal uint deltaPicOrderAlwaysZeroFlag;

            [FieldOffset(28)]
            internal int offsetForNonRefPic;

            [FieldOffset(32)]
            internal int offsetForTopToBottomField;

            [FieldOffset(36)]
            internal uint numRefFramesInPicOrderCntCycle;

            [FieldOffset(40)]
            internal global::System.IntPtr offsetForRefFrame;

            [FieldOffset(48)]
            internal uint numRefFrames;

            [FieldOffset(52)]
            internal uint gapsInFrameNumValueAllowedFlag;

            [FieldOffset(56)]
            internal uint picWidthInMbs;

            [FieldOffset(60)]
            internal uint picHeightInMbs;

            [FieldOffset(64)]
            internal uint frameCroppingFlag;

            [FieldOffset(68)]
            internal uint frameCropLeftOffset;

            [FieldOffset(72)]
            internal uint frameCropRightOffset;

            [FieldOffset(76)]
            internal uint frameCropTopOffset;

            [FieldOffset(80)]
            internal uint frameCropBottomOffset;

            [FieldOffset(84)]
            internal uint vuiParametersPresentFlag;

            [FieldOffset(88)]
            internal global::System.IntPtr vuiParameters;

            [FieldOffset(96)]
            internal uint maxDpbSize;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0seqParamSet_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.SeqParamSetT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.SeqParamSetT>();

        protected bool __ownsNativeInstance;

        internal static global::h264bsd.SeqParamSetT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::h264bsd.SeqParamSetT(native.ToPointer(), skipVTables);
        }

        internal static global::h264bsd.SeqParamSetT __CreateInstance(global::h264bsd.SeqParamSetT.__Internal native, bool skipVTables = false)
        {
            return new global::h264bsd.SeqParamSetT(native, skipVTables);
        }

        private static void* __CopyValue(global::h264bsd.SeqParamSetT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::h264bsd.SeqParamSetT.__Internal));
            *(global::h264bsd.SeqParamSetT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SeqParamSetT(global::h264bsd.SeqParamSetT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SeqParamSetT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public SeqParamSetT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.SeqParamSetT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SeqParamSetT(global::h264bsd.SeqParamSetT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.SeqParamSetT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::h264bsd.SeqParamSetT.__Internal*) __Instance) = *((global::h264bsd.SeqParamSetT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::h264bsd.SeqParamSetT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ProfileIdc
        {
            get
            {
                return ((global::h264bsd.SeqParamSetT.__Internal*) __Instance)->profileIdc;
            }

            set
            {
                ((global::h264bsd.SeqParamSetT.__Internal*)__Instance)->profileIdc = value;
            }
        }

        public uint LevelIdc
        {
            get
            {
                return ((global::h264bsd.SeqParamSetT.__Internal*) __Instance)->levelIdc;
            }

            set
            {
                ((global::h264bsd.SeqParamSetT.__Internal*)__Instance)->levelIdc = value;
            }
        }

        public uint SeqParameterSetId
        {
            get
            {
                return ((global::h264bsd.SeqParamSetT.__Internal*) __Instance)->seqParameterSetId;
            }

            set
            {
                ((global::h264bsd.SeqParamSetT.__Internal*)__Instance)->seqParameterSetId = value;
            }
        }

        public uint MaxFrameNum
        {
            get
            {
                return ((global::h264bsd.SeqParamSetT.__Internal*) __Instance)->maxFrameNum;
            }

            set
            {
                ((global::h264bsd.SeqParamSetT.__Internal*)__Instance)->maxFrameNum = value;
            }
        }

        public uint PicOrderCntType
        {
            get
            {
                return ((global::h264bsd.SeqParamSetT.__Internal*) __Instance)->picOrderCntType;
            }

            set
            {
                ((global::h264bsd.SeqParamSetT.__Internal*)__Instance)->picOrderCntType = value;
            }
        }

        public uint MaxPicOrderCntLsb
        {
            get
            {
                return ((global::h264bsd.SeqParamSetT.__Internal*) __Instance)->maxPicOrderCntLsb;
            }

            set
            {
                ((global::h264bsd.SeqParamSetT.__Internal*)__Instance)->maxPicOrderCntLsb = value;
            }
        }

        public uint DeltaPicOrderAlwaysZeroFlag
        {
            get
            {
                return ((global::h264bsd.SeqParamSetT.__Internal*) __Instance)->deltaPicOrderAlwaysZeroFlag;
            }

            set
            {
                ((global::h264bsd.SeqParamSetT.__Internal*)__Instance)->deltaPicOrderAlwaysZeroFlag = value;
            }
        }

        public int OffsetForNonRefPic
        {
            get
            {
                return ((global::h264bsd.SeqParamSetT.__Internal*) __Instance)->offsetForNonRefPic;
            }

            set
            {
                ((global::h264bsd.SeqParamSetT.__Internal*)__Instance)->offsetForNonRefPic = value;
            }
        }

        public int OffsetForTopToBottomField
        {
            get
            {
                return ((global::h264bsd.SeqParamSetT.__Internal*) __Instance)->offsetForTopToBottomField;
            }

            set
            {
                ((global::h264bsd.SeqParamSetT.__Internal*)__Instance)->offsetForTopToBottomField = value;
            }
        }

        public uint NumRefFramesInPicOrderCntCycle
        {
            get
            {
                return ((global::h264bsd.SeqParamSetT.__Internal*) __Instance)->numRefFramesInPicOrderCntCycle;
            }

            set
            {
                ((global::h264bsd.SeqParamSetT.__Internal*)__Instance)->numRefFramesInPicOrderCntCycle = value;
            }
        }

        public int* OffsetForRefFrame
        {
            get
            {
                return (int*) ((global::h264bsd.SeqParamSetT.__Internal*) __Instance)->offsetForRefFrame;
            }

            set
            {
                ((global::h264bsd.SeqParamSetT.__Internal*)__Instance)->offsetForRefFrame = (global::System.IntPtr) value;
            }
        }

        public uint NumRefFrames
        {
            get
            {
                return ((global::h264bsd.SeqParamSetT.__Internal*) __Instance)->numRefFrames;
            }

            set
            {
                ((global::h264bsd.SeqParamSetT.__Internal*)__Instance)->numRefFrames = value;
            }
        }

        public uint GapsInFrameNumValueAllowedFlag
        {
            get
            {
                return ((global::h264bsd.SeqParamSetT.__Internal*) __Instance)->gapsInFrameNumValueAllowedFlag;
            }

            set
            {
                ((global::h264bsd.SeqParamSetT.__Internal*)__Instance)->gapsInFrameNumValueAllowedFlag = value;
            }
        }

        public uint PicWidthInMbs
        {
            get
            {
                return ((global::h264bsd.SeqParamSetT.__Internal*) __Instance)->picWidthInMbs;
            }

            set
            {
                ((global::h264bsd.SeqParamSetT.__Internal*)__Instance)->picWidthInMbs = value;
            }
        }

        public uint PicHeightInMbs
        {
            get
            {
                return ((global::h264bsd.SeqParamSetT.__Internal*) __Instance)->picHeightInMbs;
            }

            set
            {
                ((global::h264bsd.SeqParamSetT.__Internal*)__Instance)->picHeightInMbs = value;
            }
        }

        public uint FrameCroppingFlag
        {
            get
            {
                return ((global::h264bsd.SeqParamSetT.__Internal*) __Instance)->frameCroppingFlag;
            }

            set
            {
                ((global::h264bsd.SeqParamSetT.__Internal*)__Instance)->frameCroppingFlag = value;
            }
        }

        public uint FrameCropLeftOffset
        {
            get
            {
                return ((global::h264bsd.SeqParamSetT.__Internal*) __Instance)->frameCropLeftOffset;
            }

            set
            {
                ((global::h264bsd.SeqParamSetT.__Internal*)__Instance)->frameCropLeftOffset = value;
            }
        }

        public uint FrameCropRightOffset
        {
            get
            {
                return ((global::h264bsd.SeqParamSetT.__Internal*) __Instance)->frameCropRightOffset;
            }

            set
            {
                ((global::h264bsd.SeqParamSetT.__Internal*)__Instance)->frameCropRightOffset = value;
            }
        }

        public uint FrameCropTopOffset
        {
            get
            {
                return ((global::h264bsd.SeqParamSetT.__Internal*) __Instance)->frameCropTopOffset;
            }

            set
            {
                ((global::h264bsd.SeqParamSetT.__Internal*)__Instance)->frameCropTopOffset = value;
            }
        }

        public uint FrameCropBottomOffset
        {
            get
            {
                return ((global::h264bsd.SeqParamSetT.__Internal*) __Instance)->frameCropBottomOffset;
            }

            set
            {
                ((global::h264bsd.SeqParamSetT.__Internal*)__Instance)->frameCropBottomOffset = value;
            }
        }

        public uint VuiParametersPresentFlag
        {
            get
            {
                return ((global::h264bsd.SeqParamSetT.__Internal*) __Instance)->vuiParametersPresentFlag;
            }

            set
            {
                ((global::h264bsd.SeqParamSetT.__Internal*)__Instance)->vuiParametersPresentFlag = value;
            }
        }

        public global::h264bsd.VuiParametersT VuiParameters
        {
            get
            {
                global::h264bsd.VuiParametersT __result0;
                if (((global::h264bsd.SeqParamSetT.__Internal*) __Instance)->vuiParameters == IntPtr.Zero) __result0 = null;
                else if (global::h264bsd.VuiParametersT.NativeToManagedMap.ContainsKey(((global::h264bsd.SeqParamSetT.__Internal*) __Instance)->vuiParameters))
                    __result0 = (global::h264bsd.VuiParametersT) global::h264bsd.VuiParametersT.NativeToManagedMap[((global::h264bsd.SeqParamSetT.__Internal*) __Instance)->vuiParameters];
                else __result0 = global::h264bsd.VuiParametersT.__CreateInstance(((global::h264bsd.SeqParamSetT.__Internal*) __Instance)->vuiParameters);
                return __result0;
            }

            set
            {
                ((global::h264bsd.SeqParamSetT.__Internal*)__Instance)->vuiParameters = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public uint MaxDpbSize
        {
            get
            {
                return ((global::h264bsd.SeqParamSetT.__Internal*) __Instance)->maxDpbSize;
            }

            set
            {
                ((global::h264bsd.SeqParamSetT.__Internal*)__Instance)->maxDpbSize = value;
            }
        }
    }

    public unsafe partial class h264bsd_seq_param_set
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdDecodeSeqParamSet@@YAIPEAUstrmData_t@@PEAUseqParamSet_t@@@Z")]
            internal static extern uint H264bsdDecodeSeqParamSet(global::System.IntPtr pStrmData, global::System.IntPtr pSeqParamSet);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdCompareSeqParamSets@@YAIPEAUseqParamSet_t@@0@Z")]
            internal static extern uint H264bsdCompareSeqParamSets(global::System.IntPtr pSps1, global::System.IntPtr pSps2);
        }

        public static uint H264bsdDecodeSeqParamSet(global::h264bsd.StrmDataT pStrmData, global::h264bsd.SeqParamSetT pSeqParamSet)
        {
            var __arg0 = ReferenceEquals(pStrmData, null) ? global::System.IntPtr.Zero : pStrmData.__Instance;
            var __arg1 = ReferenceEquals(pSeqParamSet, null) ? global::System.IntPtr.Zero : pSeqParamSet.__Instance;
            var __ret = __Internal.H264bsdDecodeSeqParamSet(__arg0, __arg1);
            return __ret;
        }

        public static uint H264bsdCompareSeqParamSets(global::h264bsd.SeqParamSetT pSps1, global::h264bsd.SeqParamSetT pSps2)
        {
            var __arg0 = ReferenceEquals(pSps1, null) ? global::System.IntPtr.Zero : pSps1.__Instance;
            var __arg1 = ReferenceEquals(pSps2, null) ? global::System.IntPtr.Zero : pSps2.__Instance;
            var __ret = __Internal.H264bsdCompareSeqParamSets(__arg0, __arg1);
            return __ret;
        }
    }

    public unsafe partial class PicParamSetT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 96)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint picParameterSetId;

            [FieldOffset(4)]
            internal uint seqParameterSetId;

            [FieldOffset(8)]
            internal uint picOrderPresentFlag;

            [FieldOffset(12)]
            internal uint numSliceGroups;

            [FieldOffset(16)]
            internal uint sliceGroupMapType;

            [FieldOffset(24)]
            internal global::System.IntPtr runLength;

            [FieldOffset(32)]
            internal global::System.IntPtr topLeft;

            [FieldOffset(40)]
            internal global::System.IntPtr bottomRight;

            [FieldOffset(48)]
            internal uint sliceGroupChangeDirectionFlag;

            [FieldOffset(52)]
            internal uint sliceGroupChangeRate;

            [FieldOffset(56)]
            internal uint picSizeInMapUnits;

            [FieldOffset(64)]
            internal global::System.IntPtr sliceGroupId;

            [FieldOffset(72)]
            internal uint numRefIdxL0Active;

            [FieldOffset(76)]
            internal uint picInitQp;

            [FieldOffset(80)]
            internal int chromaQpIndexOffset;

            [FieldOffset(84)]
            internal uint deblockingFilterControlPresentFlag;

            [FieldOffset(88)]
            internal uint constrainedIntraPredFlag;

            [FieldOffset(92)]
            internal uint redundantPicCntPresentFlag;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0picParamSet_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.PicParamSetT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.PicParamSetT>();

        protected bool __ownsNativeInstance;

        internal static global::h264bsd.PicParamSetT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::h264bsd.PicParamSetT(native.ToPointer(), skipVTables);
        }

        internal static global::h264bsd.PicParamSetT __CreateInstance(global::h264bsd.PicParamSetT.__Internal native, bool skipVTables = false)
        {
            return new global::h264bsd.PicParamSetT(native, skipVTables);
        }

        private static void* __CopyValue(global::h264bsd.PicParamSetT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::h264bsd.PicParamSetT.__Internal));
            *(global::h264bsd.PicParamSetT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PicParamSetT(global::h264bsd.PicParamSetT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PicParamSetT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public PicParamSetT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.PicParamSetT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public PicParamSetT(global::h264bsd.PicParamSetT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.PicParamSetT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::h264bsd.PicParamSetT.__Internal*) __Instance) = *((global::h264bsd.PicParamSetT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::h264bsd.PicParamSetT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint PicParameterSetId
        {
            get
            {
                return ((global::h264bsd.PicParamSetT.__Internal*) __Instance)->picParameterSetId;
            }

            set
            {
                ((global::h264bsd.PicParamSetT.__Internal*)__Instance)->picParameterSetId = value;
            }
        }

        public uint SeqParameterSetId
        {
            get
            {
                return ((global::h264bsd.PicParamSetT.__Internal*) __Instance)->seqParameterSetId;
            }

            set
            {
                ((global::h264bsd.PicParamSetT.__Internal*)__Instance)->seqParameterSetId = value;
            }
        }

        public uint PicOrderPresentFlag
        {
            get
            {
                return ((global::h264bsd.PicParamSetT.__Internal*) __Instance)->picOrderPresentFlag;
            }

            set
            {
                ((global::h264bsd.PicParamSetT.__Internal*)__Instance)->picOrderPresentFlag = value;
            }
        }

        public uint NumSliceGroups
        {
            get
            {
                return ((global::h264bsd.PicParamSetT.__Internal*) __Instance)->numSliceGroups;
            }

            set
            {
                ((global::h264bsd.PicParamSetT.__Internal*)__Instance)->numSliceGroups = value;
            }
        }

        public uint SliceGroupMapType
        {
            get
            {
                return ((global::h264bsd.PicParamSetT.__Internal*) __Instance)->sliceGroupMapType;
            }

            set
            {
                ((global::h264bsd.PicParamSetT.__Internal*)__Instance)->sliceGroupMapType = value;
            }
        }

        public uint* RunLength
        {
            get
            {
                return (uint*) ((global::h264bsd.PicParamSetT.__Internal*) __Instance)->runLength;
            }

            set
            {
                ((global::h264bsd.PicParamSetT.__Internal*)__Instance)->runLength = (global::System.IntPtr) value;
            }
        }

        public uint* TopLeft
        {
            get
            {
                return (uint*) ((global::h264bsd.PicParamSetT.__Internal*) __Instance)->topLeft;
            }

            set
            {
                ((global::h264bsd.PicParamSetT.__Internal*)__Instance)->topLeft = (global::System.IntPtr) value;
            }
        }

        public uint* BottomRight
        {
            get
            {
                return (uint*) ((global::h264bsd.PicParamSetT.__Internal*) __Instance)->bottomRight;
            }

            set
            {
                ((global::h264bsd.PicParamSetT.__Internal*)__Instance)->bottomRight = (global::System.IntPtr) value;
            }
        }

        public uint SliceGroupChangeDirectionFlag
        {
            get
            {
                return ((global::h264bsd.PicParamSetT.__Internal*) __Instance)->sliceGroupChangeDirectionFlag;
            }

            set
            {
                ((global::h264bsd.PicParamSetT.__Internal*)__Instance)->sliceGroupChangeDirectionFlag = value;
            }
        }

        public uint SliceGroupChangeRate
        {
            get
            {
                return ((global::h264bsd.PicParamSetT.__Internal*) __Instance)->sliceGroupChangeRate;
            }

            set
            {
                ((global::h264bsd.PicParamSetT.__Internal*)__Instance)->sliceGroupChangeRate = value;
            }
        }

        public uint PicSizeInMapUnits
        {
            get
            {
                return ((global::h264bsd.PicParamSetT.__Internal*) __Instance)->picSizeInMapUnits;
            }

            set
            {
                ((global::h264bsd.PicParamSetT.__Internal*)__Instance)->picSizeInMapUnits = value;
            }
        }

        public uint* SliceGroupId
        {
            get
            {
                return (uint*) ((global::h264bsd.PicParamSetT.__Internal*) __Instance)->sliceGroupId;
            }

            set
            {
                ((global::h264bsd.PicParamSetT.__Internal*)__Instance)->sliceGroupId = (global::System.IntPtr) value;
            }
        }

        public uint NumRefIdxL0Active
        {
            get
            {
                return ((global::h264bsd.PicParamSetT.__Internal*) __Instance)->numRefIdxL0Active;
            }

            set
            {
                ((global::h264bsd.PicParamSetT.__Internal*)__Instance)->numRefIdxL0Active = value;
            }
        }

        public uint PicInitQp
        {
            get
            {
                return ((global::h264bsd.PicParamSetT.__Internal*) __Instance)->picInitQp;
            }

            set
            {
                ((global::h264bsd.PicParamSetT.__Internal*)__Instance)->picInitQp = value;
            }
        }

        public int ChromaQpIndexOffset
        {
            get
            {
                return ((global::h264bsd.PicParamSetT.__Internal*) __Instance)->chromaQpIndexOffset;
            }

            set
            {
                ((global::h264bsd.PicParamSetT.__Internal*)__Instance)->chromaQpIndexOffset = value;
            }
        }

        public uint DeblockingFilterControlPresentFlag
        {
            get
            {
                return ((global::h264bsd.PicParamSetT.__Internal*) __Instance)->deblockingFilterControlPresentFlag;
            }

            set
            {
                ((global::h264bsd.PicParamSetT.__Internal*)__Instance)->deblockingFilterControlPresentFlag = value;
            }
        }

        public uint ConstrainedIntraPredFlag
        {
            get
            {
                return ((global::h264bsd.PicParamSetT.__Internal*) __Instance)->constrainedIntraPredFlag;
            }

            set
            {
                ((global::h264bsd.PicParamSetT.__Internal*)__Instance)->constrainedIntraPredFlag = value;
            }
        }

        public uint RedundantPicCntPresentFlag
        {
            get
            {
                return ((global::h264bsd.PicParamSetT.__Internal*) __Instance)->redundantPicCntPresentFlag;
            }

            set
            {
                ((global::h264bsd.PicParamSetT.__Internal*)__Instance)->redundantPicCntPresentFlag = value;
            }
        }
    }

    public unsafe partial class h264bsd_pic_param_set
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdDecodePicParamSet@@YAIPEAUstrmData_t@@PEAUpicParamSet_t@@@Z")]
            internal static extern uint H264bsdDecodePicParamSet(global::System.IntPtr pStrmData, global::System.IntPtr pPicParamSet);
        }

        public static uint H264bsdDecodePicParamSet(global::h264bsd.StrmDataT pStrmData, global::h264bsd.PicParamSetT pPicParamSet)
        {
            var __arg0 = ReferenceEquals(pStrmData, null) ? global::System.IntPtr.Zero : pStrmData.__Instance;
            var __arg1 = ReferenceEquals(pPicParamSet, null) ? global::System.IntPtr.Zero : pPicParamSet.__Instance;
            var __ret = __Internal.H264bsdDecodePicParamSet(__arg0, __arg1);
            return __ret;
        }
    }

    public unsafe partial class ImageT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr data;

            [FieldOffset(8)]
            internal uint width;

            [FieldOffset(12)]
            internal uint height;

            [FieldOffset(16)]
            internal global::System.IntPtr luma;

            [FieldOffset(24)]
            internal global::System.IntPtr cb;

            [FieldOffset(32)]
            internal global::System.IntPtr cr;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0image_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.ImageT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.ImageT>();

        protected bool __ownsNativeInstance;

        internal static global::h264bsd.ImageT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::h264bsd.ImageT(native.ToPointer(), skipVTables);
        }

        internal static global::h264bsd.ImageT __CreateInstance(global::h264bsd.ImageT.__Internal native, bool skipVTables = false)
        {
            return new global::h264bsd.ImageT(native, skipVTables);
        }

        private static void* __CopyValue(global::h264bsd.ImageT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::h264bsd.ImageT.__Internal));
            *(global::h264bsd.ImageT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImageT(global::h264bsd.ImageT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImageT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImageT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.ImageT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImageT(global::h264bsd.ImageT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.ImageT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::h264bsd.ImageT.__Internal*) __Instance) = *((global::h264bsd.ImageT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::h264bsd.ImageT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte* Data
        {
            get
            {
                return (byte*) ((global::h264bsd.ImageT.__Internal*) __Instance)->data;
            }

            set
            {
                ((global::h264bsd.ImageT.__Internal*)__Instance)->data = (global::System.IntPtr) value;
            }
        }

        public uint Width
        {
            get
            {
                return ((global::h264bsd.ImageT.__Internal*) __Instance)->width;
            }

            set
            {
                ((global::h264bsd.ImageT.__Internal*)__Instance)->width = value;
            }
        }

        public uint Height
        {
            get
            {
                return ((global::h264bsd.ImageT.__Internal*) __Instance)->height;
            }

            set
            {
                ((global::h264bsd.ImageT.__Internal*)__Instance)->height = value;
            }
        }

        public byte* Luma
        {
            get
            {
                return (byte*) ((global::h264bsd.ImageT.__Internal*) __Instance)->luma;
            }

            set
            {
                ((global::h264bsd.ImageT.__Internal*)__Instance)->luma = (global::System.IntPtr) value;
            }
        }

        public byte* Cb
        {
            get
            {
                return (byte*) ((global::h264bsd.ImageT.__Internal*) __Instance)->cb;
            }

            set
            {
                ((global::h264bsd.ImageT.__Internal*)__Instance)->cb = (global::System.IntPtr) value;
            }
        }

        public byte* Cr
        {
            get
            {
                return (byte*) ((global::h264bsd.ImageT.__Internal*) __Instance)->cr;
            }

            set
            {
                ((global::h264bsd.ImageT.__Internal*)__Instance)->cr = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class h264bsd_image
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdWriteMacroblock@@YAXPEAUimage_t@@PEAE@Z")]
            internal static extern void H264bsdWriteMacroblock(global::System.IntPtr image, byte* data);
        }

        public static void H264bsdWriteMacroblock(global::h264bsd.ImageT image, byte* data)
        {
            var __arg0 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            __Internal.H264bsdWriteMacroblock(__arg0, data);
        }
    }

    public enum DpbPictureStatusE
    {
        UNUSED = 0,
        NON_EXISTING = 1,
        SHORT_TERM = 2,
        LONG_TERM = 3
    }

    public unsafe partial class DpbPictureT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr data;

            [FieldOffset(8)]
            internal global::System.IntPtr pAllocatedData;

            [FieldOffset(16)]
            internal int picNum;

            [FieldOffset(20)]
            internal uint frameNum;

            [FieldOffset(24)]
            internal int picOrderCnt;

            [FieldOffset(28)]
            internal global::h264bsd.DpbPictureStatusE status;

            [FieldOffset(32)]
            internal uint toBeDisplayed;

            [FieldOffset(36)]
            internal uint picId;

            [FieldOffset(40)]
            internal uint numErrMbs;

            [FieldOffset(44)]
            internal uint isIdr;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0dpbPicture_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.DpbPictureT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.DpbPictureT>();

        protected bool __ownsNativeInstance;

        internal static global::h264bsd.DpbPictureT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::h264bsd.DpbPictureT(native.ToPointer(), skipVTables);
        }

        internal static global::h264bsd.DpbPictureT __CreateInstance(global::h264bsd.DpbPictureT.__Internal native, bool skipVTables = false)
        {
            return new global::h264bsd.DpbPictureT(native, skipVTables);
        }

        private static void* __CopyValue(global::h264bsd.DpbPictureT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::h264bsd.DpbPictureT.__Internal));
            *(global::h264bsd.DpbPictureT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DpbPictureT(global::h264bsd.DpbPictureT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DpbPictureT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public DpbPictureT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.DpbPictureT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public DpbPictureT(global::h264bsd.DpbPictureT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.DpbPictureT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::h264bsd.DpbPictureT.__Internal*) __Instance) = *((global::h264bsd.DpbPictureT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::h264bsd.DpbPictureT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte* Data
        {
            get
            {
                return (byte*) ((global::h264bsd.DpbPictureT.__Internal*) __Instance)->data;
            }

            set
            {
                ((global::h264bsd.DpbPictureT.__Internal*)__Instance)->data = (global::System.IntPtr) value;
            }
        }

        public byte* PAllocatedData
        {
            get
            {
                return (byte*) ((global::h264bsd.DpbPictureT.__Internal*) __Instance)->pAllocatedData;
            }

            set
            {
                ((global::h264bsd.DpbPictureT.__Internal*)__Instance)->pAllocatedData = (global::System.IntPtr) value;
            }
        }

        public int PicNum
        {
            get
            {
                return ((global::h264bsd.DpbPictureT.__Internal*) __Instance)->picNum;
            }

            set
            {
                ((global::h264bsd.DpbPictureT.__Internal*)__Instance)->picNum = value;
            }
        }

        public uint FrameNum
        {
            get
            {
                return ((global::h264bsd.DpbPictureT.__Internal*) __Instance)->frameNum;
            }

            set
            {
                ((global::h264bsd.DpbPictureT.__Internal*)__Instance)->frameNum = value;
            }
        }

        public int PicOrderCnt
        {
            get
            {
                return ((global::h264bsd.DpbPictureT.__Internal*) __Instance)->picOrderCnt;
            }

            set
            {
                ((global::h264bsd.DpbPictureT.__Internal*)__Instance)->picOrderCnt = value;
            }
        }

        public global::h264bsd.DpbPictureStatusE Status
        {
            get
            {
                return ((global::h264bsd.DpbPictureT.__Internal*) __Instance)->status;
            }

            set
            {
                ((global::h264bsd.DpbPictureT.__Internal*)__Instance)->status = value;
            }
        }

        public uint ToBeDisplayed
        {
            get
            {
                return ((global::h264bsd.DpbPictureT.__Internal*) __Instance)->toBeDisplayed;
            }

            set
            {
                ((global::h264bsd.DpbPictureT.__Internal*)__Instance)->toBeDisplayed = value;
            }
        }

        public uint PicId
        {
            get
            {
                return ((global::h264bsd.DpbPictureT.__Internal*) __Instance)->picId;
            }

            set
            {
                ((global::h264bsd.DpbPictureT.__Internal*)__Instance)->picId = value;
            }
        }

        public uint NumErrMbs
        {
            get
            {
                return ((global::h264bsd.DpbPictureT.__Internal*) __Instance)->numErrMbs;
            }

            set
            {
                ((global::h264bsd.DpbPictureT.__Internal*)__Instance)->numErrMbs = value;
            }
        }

        public uint IsIdr
        {
            get
            {
                return ((global::h264bsd.DpbPictureT.__Internal*) __Instance)->isIdr;
            }

            set
            {
                ((global::h264bsd.DpbPictureT.__Internal*)__Instance)->isIdr = value;
            }
        }
    }

    public unsafe partial class DpbOutPictureT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr data;

            [FieldOffset(8)]
            internal uint picId;

            [FieldOffset(12)]
            internal uint numErrMbs;

            [FieldOffset(16)]
            internal uint isIdr;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0dpbOutPicture_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.DpbOutPictureT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.DpbOutPictureT>();

        protected bool __ownsNativeInstance;

        internal static global::h264bsd.DpbOutPictureT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::h264bsd.DpbOutPictureT(native.ToPointer(), skipVTables);
        }

        internal static global::h264bsd.DpbOutPictureT __CreateInstance(global::h264bsd.DpbOutPictureT.__Internal native, bool skipVTables = false)
        {
            return new global::h264bsd.DpbOutPictureT(native, skipVTables);
        }

        private static void* __CopyValue(global::h264bsd.DpbOutPictureT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::h264bsd.DpbOutPictureT.__Internal));
            *(global::h264bsd.DpbOutPictureT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DpbOutPictureT(global::h264bsd.DpbOutPictureT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DpbOutPictureT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public DpbOutPictureT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.DpbOutPictureT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public DpbOutPictureT(global::h264bsd.DpbOutPictureT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.DpbOutPictureT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::h264bsd.DpbOutPictureT.__Internal*) __Instance) = *((global::h264bsd.DpbOutPictureT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::h264bsd.DpbOutPictureT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte* Data
        {
            get
            {
                return (byte*) ((global::h264bsd.DpbOutPictureT.__Internal*) __Instance)->data;
            }

            set
            {
                ((global::h264bsd.DpbOutPictureT.__Internal*)__Instance)->data = (global::System.IntPtr) value;
            }
        }

        public uint PicId
        {
            get
            {
                return ((global::h264bsd.DpbOutPictureT.__Internal*) __Instance)->picId;
            }

            set
            {
                ((global::h264bsd.DpbOutPictureT.__Internal*)__Instance)->picId = value;
            }
        }

        public uint NumErrMbs
        {
            get
            {
                return ((global::h264bsd.DpbOutPictureT.__Internal*) __Instance)->numErrMbs;
            }

            set
            {
                ((global::h264bsd.DpbOutPictureT.__Internal*)__Instance)->numErrMbs = value;
            }
        }

        public uint IsIdr
        {
            get
            {
                return ((global::h264bsd.DpbOutPictureT.__Internal*) __Instance)->isIdr;
            }

            set
            {
                ((global::h264bsd.DpbOutPictureT.__Internal*)__Instance)->isIdr = value;
            }
        }
    }

    public unsafe partial class DpbStorageT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr buffer;

            [FieldOffset(8)]
            internal global::System.IntPtr list;

            [FieldOffset(16)]
            internal global::System.IntPtr currentOut;

            [FieldOffset(24)]
            internal global::System.IntPtr outBuf;

            [FieldOffset(32)]
            internal uint numOut;

            [FieldOffset(36)]
            internal uint outIndex;

            [FieldOffset(40)]
            internal uint maxRefFrames;

            [FieldOffset(44)]
            internal uint dpbSize;

            [FieldOffset(48)]
            internal uint maxFrameNum;

            [FieldOffset(52)]
            internal uint maxLongTermFrameIdx;

            [FieldOffset(56)]
            internal uint numRefFrames;

            [FieldOffset(60)]
            internal uint fullness;

            [FieldOffset(64)]
            internal uint prevRefFrameNum;

            [FieldOffset(68)]
            internal uint lastContainsMmco5;

            [FieldOffset(72)]
            internal uint noReordering;

            [FieldOffset(76)]
            internal uint flushed;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0dpbStorage_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.DpbStorageT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.DpbStorageT>();

        protected bool __ownsNativeInstance;

        internal static global::h264bsd.DpbStorageT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::h264bsd.DpbStorageT(native.ToPointer(), skipVTables);
        }

        internal static global::h264bsd.DpbStorageT __CreateInstance(global::h264bsd.DpbStorageT.__Internal native, bool skipVTables = false)
        {
            return new global::h264bsd.DpbStorageT(native, skipVTables);
        }

        private static void* __CopyValue(global::h264bsd.DpbStorageT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::h264bsd.DpbStorageT.__Internal));
            *(global::h264bsd.DpbStorageT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DpbStorageT(global::h264bsd.DpbStorageT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DpbStorageT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public DpbStorageT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.DpbStorageT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public DpbStorageT(global::h264bsd.DpbStorageT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.DpbStorageT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::h264bsd.DpbStorageT.__Internal*) __Instance) = *((global::h264bsd.DpbStorageT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::h264bsd.DpbStorageT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::h264bsd.DpbPictureT Buffer
        {
            get
            {
                global::h264bsd.DpbPictureT __result0;
                if (((global::h264bsd.DpbStorageT.__Internal*) __Instance)->buffer == IntPtr.Zero) __result0 = null;
                else if (global::h264bsd.DpbPictureT.NativeToManagedMap.ContainsKey(((global::h264bsd.DpbStorageT.__Internal*) __Instance)->buffer))
                    __result0 = (global::h264bsd.DpbPictureT) global::h264bsd.DpbPictureT.NativeToManagedMap[((global::h264bsd.DpbStorageT.__Internal*) __Instance)->buffer];
                else __result0 = global::h264bsd.DpbPictureT.__CreateInstance(((global::h264bsd.DpbStorageT.__Internal*) __Instance)->buffer);
                return __result0;
            }

            set
            {
                ((global::h264bsd.DpbStorageT.__Internal*)__Instance)->buffer = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::h264bsd.DpbPictureT List
        {
            get
            {
                global::h264bsd.DpbPictureT __result0;
                if (((global::h264bsd.DpbStorageT.__Internal*) __Instance)->list == IntPtr.Zero) __result0 = null;
                else if (global::h264bsd.DpbPictureT.NativeToManagedMap.ContainsKey(((global::h264bsd.DpbStorageT.__Internal*) __Instance)->list))
                    __result0 = (global::h264bsd.DpbPictureT) global::h264bsd.DpbPictureT.NativeToManagedMap[((global::h264bsd.DpbStorageT.__Internal*) __Instance)->list];
                else __result0 = global::h264bsd.DpbPictureT.__CreateInstance(((global::h264bsd.DpbStorageT.__Internal*) __Instance)->list);
                return __result0;
            }

            set
            {
                var __value = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                ((global::h264bsd.DpbStorageT.__Internal*)__Instance)->list = new global::System.IntPtr(&__value);
            }
        }

        public global::h264bsd.DpbPictureT CurrentOut
        {
            get
            {
                global::h264bsd.DpbPictureT __result0;
                if (((global::h264bsd.DpbStorageT.__Internal*) __Instance)->currentOut == IntPtr.Zero) __result0 = null;
                else if (global::h264bsd.DpbPictureT.NativeToManagedMap.ContainsKey(((global::h264bsd.DpbStorageT.__Internal*) __Instance)->currentOut))
                    __result0 = (global::h264bsd.DpbPictureT) global::h264bsd.DpbPictureT.NativeToManagedMap[((global::h264bsd.DpbStorageT.__Internal*) __Instance)->currentOut];
                else __result0 = global::h264bsd.DpbPictureT.__CreateInstance(((global::h264bsd.DpbStorageT.__Internal*) __Instance)->currentOut);
                return __result0;
            }

            set
            {
                ((global::h264bsd.DpbStorageT.__Internal*)__Instance)->currentOut = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::h264bsd.DpbOutPictureT OutBuf
        {
            get
            {
                global::h264bsd.DpbOutPictureT __result0;
                if (((global::h264bsd.DpbStorageT.__Internal*) __Instance)->outBuf == IntPtr.Zero) __result0 = null;
                else if (global::h264bsd.DpbOutPictureT.NativeToManagedMap.ContainsKey(((global::h264bsd.DpbStorageT.__Internal*) __Instance)->outBuf))
                    __result0 = (global::h264bsd.DpbOutPictureT) global::h264bsd.DpbOutPictureT.NativeToManagedMap[((global::h264bsd.DpbStorageT.__Internal*) __Instance)->outBuf];
                else __result0 = global::h264bsd.DpbOutPictureT.__CreateInstance(((global::h264bsd.DpbStorageT.__Internal*) __Instance)->outBuf);
                return __result0;
            }

            set
            {
                ((global::h264bsd.DpbStorageT.__Internal*)__Instance)->outBuf = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public uint NumOut
        {
            get
            {
                return ((global::h264bsd.DpbStorageT.__Internal*) __Instance)->numOut;
            }

            set
            {
                ((global::h264bsd.DpbStorageT.__Internal*)__Instance)->numOut = value;
            }
        }

        public uint OutIndex
        {
            get
            {
                return ((global::h264bsd.DpbStorageT.__Internal*) __Instance)->outIndex;
            }

            set
            {
                ((global::h264bsd.DpbStorageT.__Internal*)__Instance)->outIndex = value;
            }
        }

        public uint MaxRefFrames
        {
            get
            {
                return ((global::h264bsd.DpbStorageT.__Internal*) __Instance)->maxRefFrames;
            }

            set
            {
                ((global::h264bsd.DpbStorageT.__Internal*)__Instance)->maxRefFrames = value;
            }
        }

        public uint DpbSize
        {
            get
            {
                return ((global::h264bsd.DpbStorageT.__Internal*) __Instance)->dpbSize;
            }

            set
            {
                ((global::h264bsd.DpbStorageT.__Internal*)__Instance)->dpbSize = value;
            }
        }

        public uint MaxFrameNum
        {
            get
            {
                return ((global::h264bsd.DpbStorageT.__Internal*) __Instance)->maxFrameNum;
            }

            set
            {
                ((global::h264bsd.DpbStorageT.__Internal*)__Instance)->maxFrameNum = value;
            }
        }

        public uint MaxLongTermFrameIdx
        {
            get
            {
                return ((global::h264bsd.DpbStorageT.__Internal*) __Instance)->maxLongTermFrameIdx;
            }

            set
            {
                ((global::h264bsd.DpbStorageT.__Internal*)__Instance)->maxLongTermFrameIdx = value;
            }
        }

        public uint NumRefFrames
        {
            get
            {
                return ((global::h264bsd.DpbStorageT.__Internal*) __Instance)->numRefFrames;
            }

            set
            {
                ((global::h264bsd.DpbStorageT.__Internal*)__Instance)->numRefFrames = value;
            }
        }

        public uint Fullness
        {
            get
            {
                return ((global::h264bsd.DpbStorageT.__Internal*) __Instance)->fullness;
            }

            set
            {
                ((global::h264bsd.DpbStorageT.__Internal*)__Instance)->fullness = value;
            }
        }

        public uint PrevRefFrameNum
        {
            get
            {
                return ((global::h264bsd.DpbStorageT.__Internal*) __Instance)->prevRefFrameNum;
            }

            set
            {
                ((global::h264bsd.DpbStorageT.__Internal*)__Instance)->prevRefFrameNum = value;
            }
        }

        public uint LastContainsMmco5
        {
            get
            {
                return ((global::h264bsd.DpbStorageT.__Internal*) __Instance)->lastContainsMmco5;
            }

            set
            {
                ((global::h264bsd.DpbStorageT.__Internal*)__Instance)->lastContainsMmco5 = value;
            }
        }

        public uint NoReordering
        {
            get
            {
                return ((global::h264bsd.DpbStorageT.__Internal*) __Instance)->noReordering;
            }

            set
            {
                ((global::h264bsd.DpbStorageT.__Internal*)__Instance)->noReordering = value;
            }
        }

        public uint Flushed
        {
            get
            {
                return ((global::h264bsd.DpbStorageT.__Internal*) __Instance)->flushed;
            }

            set
            {
                ((global::h264bsd.DpbStorageT.__Internal*)__Instance)->flushed = value;
            }
        }
    }

    public unsafe partial class h264bsd_dpb
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdInitDpb@@YAIPEAUdpbStorage_t@@IIIII@Z")]
            internal static extern uint H264bsdInitDpb(global::System.IntPtr dpb, uint picSizeInMbs, uint dpbSize, uint numRefFrames, uint maxFrameNum, uint noReordering);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdResetDpb@@YAIPEAUdpbStorage_t@@IIIII@Z")]
            internal static extern uint H264bsdResetDpb(global::System.IntPtr dpb, uint picSizeInMbs, uint dpbSize, uint numRefFrames, uint maxFrameNum, uint noReordering);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdInitRefPicList@@YAXPEAUdpbStorage_t@@@Z")]
            internal static extern void H264bsdInitRefPicList(global::System.IntPtr dpb);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdAllocateDpbImage@@YAPEAEPEAUdpbStorage_t@@@Z")]
            internal static extern byte* H264bsdAllocateDpbImage(global::System.IntPtr dpb);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdGetRefPicData@@YAPEAEPEAUdpbStorage_t@@I@Z")]
            internal static extern byte* H264bsdGetRefPicData(global::System.IntPtr dpb, uint index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdReorderRefPicList@@YAIPEAUdpbStorage_t@@PEAUrefPicListReordering_t@@II@Z")]
            internal static extern uint H264bsdReorderRefPicList(global::System.IntPtr dpb, global::System.IntPtr order, uint currFrameNum, uint numRefIdxActive);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdMarkDecRefPic@@YAIPEAUdpbStorage_t@@PEAUdecRefPicMarking_t@@PEAUimage_t@@IHIII@Z")]
            internal static extern uint H264bsdMarkDecRefPic(global::System.IntPtr dpb, global::System.IntPtr mark, global::System.IntPtr image, uint frameNum, int picOrderCnt, uint isIdr, uint picId, uint numErrMbs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdCheckGapsInFrameNum@@YAIPEAUdpbStorage_t@@III@Z")]
            internal static extern uint H264bsdCheckGapsInFrameNum(global::System.IntPtr dpb, uint frameNum, uint isRefPic, uint gapsAllowed);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdDpbOutputPicture@@YAPEAUdpbOutPicture_t@@PEAUdpbStorage_t@@@Z")]
            internal static extern global::System.IntPtr H264bsdDpbOutputPicture(global::System.IntPtr dpb);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdFlushDpb@@YAXPEAUdpbStorage_t@@@Z")]
            internal static extern void H264bsdFlushDpb(global::System.IntPtr dpb);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdFreeDpb@@YAXPEAUdpbStorage_t@@@Z")]
            internal static extern void H264bsdFreeDpb(global::System.IntPtr dpb);
        }

        public static uint H264bsdInitDpb(global::h264bsd.DpbStorageT dpb, uint picSizeInMbs, uint dpbSize, uint numRefFrames, uint maxFrameNum, uint noReordering)
        {
            var __arg0 = ReferenceEquals(dpb, null) ? global::System.IntPtr.Zero : dpb.__Instance;
            var __ret = __Internal.H264bsdInitDpb(__arg0, picSizeInMbs, dpbSize, numRefFrames, maxFrameNum, noReordering);
            return __ret;
        }

        public static uint H264bsdResetDpb(global::h264bsd.DpbStorageT dpb, uint picSizeInMbs, uint dpbSize, uint numRefFrames, uint maxFrameNum, uint noReordering)
        {
            var __arg0 = ReferenceEquals(dpb, null) ? global::System.IntPtr.Zero : dpb.__Instance;
            var __ret = __Internal.H264bsdResetDpb(__arg0, picSizeInMbs, dpbSize, numRefFrames, maxFrameNum, noReordering);
            return __ret;
        }

        public static void H264bsdInitRefPicList(global::h264bsd.DpbStorageT dpb)
        {
            var __arg0 = ReferenceEquals(dpb, null) ? global::System.IntPtr.Zero : dpb.__Instance;
            __Internal.H264bsdInitRefPicList(__arg0);
        }

        public static byte* H264bsdAllocateDpbImage(global::h264bsd.DpbStorageT dpb)
        {
            var __arg0 = ReferenceEquals(dpb, null) ? global::System.IntPtr.Zero : dpb.__Instance;
            var __ret = __Internal.H264bsdAllocateDpbImage(__arg0);
            return __ret;
        }

        public static byte* H264bsdGetRefPicData(global::h264bsd.DpbStorageT dpb, uint index)
        {
            var __arg0 = ReferenceEquals(dpb, null) ? global::System.IntPtr.Zero : dpb.__Instance;
            var __ret = __Internal.H264bsdGetRefPicData(__arg0, index);
            return __ret;
        }

        public static uint H264bsdReorderRefPicList(global::h264bsd.DpbStorageT dpb, global::h264bsd.RefPicListReorderingT order, uint currFrameNum, uint numRefIdxActive)
        {
            var __arg0 = ReferenceEquals(dpb, null) ? global::System.IntPtr.Zero : dpb.__Instance;
            var __arg1 = ReferenceEquals(order, null) ? global::System.IntPtr.Zero : order.__Instance;
            var __ret = __Internal.H264bsdReorderRefPicList(__arg0, __arg1, currFrameNum, numRefIdxActive);
            return __ret;
        }

        public static uint H264bsdMarkDecRefPic(global::h264bsd.DpbStorageT dpb, global::h264bsd.DecRefPicMarkingT mark, global::h264bsd.ImageT image, uint frameNum, int picOrderCnt, uint isIdr, uint picId, uint numErrMbs)
        {
            var __arg0 = ReferenceEquals(dpb, null) ? global::System.IntPtr.Zero : dpb.__Instance;
            var __arg1 = ReferenceEquals(mark, null) ? global::System.IntPtr.Zero : mark.__Instance;
            var __arg2 = ReferenceEquals(image, null) ? global::System.IntPtr.Zero : image.__Instance;
            var __ret = __Internal.H264bsdMarkDecRefPic(__arg0, __arg1, __arg2, frameNum, picOrderCnt, isIdr, picId, numErrMbs);
            return __ret;
        }

        public static uint H264bsdCheckGapsInFrameNum(global::h264bsd.DpbStorageT dpb, uint frameNum, uint isRefPic, uint gapsAllowed)
        {
            var __arg0 = ReferenceEquals(dpb, null) ? global::System.IntPtr.Zero : dpb.__Instance;
            var __ret = __Internal.H264bsdCheckGapsInFrameNum(__arg0, frameNum, isRefPic, gapsAllowed);
            return __ret;
        }

        public static global::h264bsd.DpbOutPictureT H264bsdDpbOutputPicture(global::h264bsd.DpbStorageT dpb)
        {
            var __arg0 = ReferenceEquals(dpb, null) ? global::System.IntPtr.Zero : dpb.__Instance;
            var __ret = __Internal.H264bsdDpbOutputPicture(__arg0);
            global::h264bsd.DpbOutPictureT __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::h264bsd.DpbOutPictureT.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::h264bsd.DpbOutPictureT) global::h264bsd.DpbOutPictureT.NativeToManagedMap[__ret];
            else __result0 = global::h264bsd.DpbOutPictureT.__CreateInstance(__ret);
            return __result0;
        }

        public static void H264bsdFlushDpb(global::h264bsd.DpbStorageT dpb)
        {
            var __arg0 = ReferenceEquals(dpb, null) ? global::System.IntPtr.Zero : dpb.__Instance;
            __Internal.H264bsdFlushDpb(__arg0);
        }

        public static void H264bsdFreeDpb(global::h264bsd.DpbStorageT dpb)
        {
            var __arg0 = ReferenceEquals(dpb, null) ? global::System.IntPtr.Zero : dpb.__Instance;
            __Internal.H264bsdFreeDpb(__arg0);
        }
    }

    public unsafe partial class PocStorageT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint prevPicOrderCntLsb;

            [FieldOffset(4)]
            internal int prevPicOrderCntMsb;

            [FieldOffset(8)]
            internal uint prevFrameNum;

            [FieldOffset(12)]
            internal uint prevFrameNumOffset;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0pocStorage_t@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.PocStorageT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::h264bsd.PocStorageT>();

        protected bool __ownsNativeInstance;

        internal static global::h264bsd.PocStorageT __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::h264bsd.PocStorageT(native.ToPointer(), skipVTables);
        }

        internal static global::h264bsd.PocStorageT __CreateInstance(global::h264bsd.PocStorageT.__Internal native, bool skipVTables = false)
        {
            return new global::h264bsd.PocStorageT(native, skipVTables);
        }

        private static void* __CopyValue(global::h264bsd.PocStorageT.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::h264bsd.PocStorageT.__Internal));
            *(global::h264bsd.PocStorageT.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PocStorageT(global::h264bsd.PocStorageT.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PocStorageT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public PocStorageT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.PocStorageT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public PocStorageT(global::h264bsd.PocStorageT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::h264bsd.PocStorageT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::h264bsd.PocStorageT.__Internal*) __Instance) = *((global::h264bsd.PocStorageT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::h264bsd.PocStorageT __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint PrevPicOrderCntLsb
        {
            get
            {
                return ((global::h264bsd.PocStorageT.__Internal*) __Instance)->prevPicOrderCntLsb;
            }

            set
            {
                ((global::h264bsd.PocStorageT.__Internal*)__Instance)->prevPicOrderCntLsb = value;
            }
        }

        public int PrevPicOrderCntMsb
        {
            get
            {
                return ((global::h264bsd.PocStorageT.__Internal*) __Instance)->prevPicOrderCntMsb;
            }

            set
            {
                ((global::h264bsd.PocStorageT.__Internal*)__Instance)->prevPicOrderCntMsb = value;
            }
        }

        public uint PrevFrameNum
        {
            get
            {
                return ((global::h264bsd.PocStorageT.__Internal*) __Instance)->prevFrameNum;
            }

            set
            {
                ((global::h264bsd.PocStorageT.__Internal*)__Instance)->prevFrameNum = value;
            }
        }

        public uint PrevFrameNumOffset
        {
            get
            {
                return ((global::h264bsd.PocStorageT.__Internal*) __Instance)->prevFrameNumOffset;
            }

            set
            {
                ((global::h264bsd.PocStorageT.__Internal*)__Instance)->prevFrameNumOffset = value;
            }
        }
    }

    public unsafe partial class h264bsd_pic_order_cnt
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("h264bsd", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?h264bsdDecodePicOrderCnt@@YAHPEAUpocStorage_t@@PEAUseqParamSet_t@@PEAUsliceHeader_t@@PEAUnalUnit_t@@@Z")]
            internal static extern int H264bsdDecodePicOrderCnt(global::System.IntPtr poc, global::System.IntPtr sps, global::System.IntPtr sliceHeader, global::System.IntPtr pNalUnit);
        }

        public static int H264bsdDecodePicOrderCnt(global::h264bsd.PocStorageT poc, global::h264bsd.SeqParamSetT sps, global::h264bsd.SliceHeaderT sliceHeader, global::h264bsd.NalUnitT pNalUnit)
        {
            var __arg0 = ReferenceEquals(poc, null) ? global::System.IntPtr.Zero : poc.__Instance;
            var __arg1 = ReferenceEquals(sps, null) ? global::System.IntPtr.Zero : sps.__Instance;
            var __arg2 = ReferenceEquals(sliceHeader, null) ? global::System.IntPtr.Zero : sliceHeader.__Instance;
            var __arg3 = ReferenceEquals(pNalUnit, null) ? global::System.IntPtr.Zero : pNalUnit.__Instance;
            var __ret = __Internal.H264bsdDecodePicOrderCnt(__arg0, __arg1, __arg2, __arg3);
            return __ret;
        }
    }
}
